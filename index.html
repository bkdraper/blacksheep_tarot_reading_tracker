<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#28a745">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Tarot Reading Tracker" id="appleTitle">
    <meta name="application-name" content="Tarot Reading Tracker" id="appName">
    <meta name="msapplication-starturl" content="/">
    <link rel="icon" type="image/png" id="favicon" href="/logo192.png">

    <title>Tarot Reading Tracker</title>
    <script>
        // Global app title variable
        function isDevelopmentMode() {
            return window.location.hostname === 'localhost' || 
                   window.location.hostname === '127.0.0.1' ||
                   window.location.hostname.startsWith('192.168.') ||
                   window.location.hostname.startsWith('10.') ||
                   window.location.port === '8080' ||
                   window.location.protocol === 'file:' ||
                   window.location.search.includes('dev=true');
        }
        window.APP_TITLE = isDevelopmentMode() ? '[DEV] Tarot Reading Tracker' : 'Tarot Reading Tracker';
        window.APP_LOGO = isDevelopmentMode() ? '/logo192-dev.png' : '/logo192.png';
        document.title = window.APP_TITLE;
        document.getElementById('favicon').href = window.APP_LOGO;
        document.getElementById('appleTitle').content = window.APP_TITLE;
        document.getElementById('appName').content = window.APP_TITLE;
        // Set header title after DOM loads
        document.addEventListener('DOMContentLoaded', () => {
            const headerTitle = document.getElementById('headerTitle');
            if (headerTitle) headerTitle.textContent = window.APP_TITLE;
        });
    </script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif; 
            background: #f5f5f5;
            font-size: 16px;
            -webkit-text-size-adjust: 100%;
            touch-action: manipulation;
            margin: 0;
        }
        .header {
            background: #28a745;
            color: white;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        .header h1 {
            font-size: 18px;
            font-weight: 600;
            margin: 0;
        }
        .header-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .version-badge {
            background: rgba(255,255,255,0.2);
            padding: 2px 6px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 500;
        }
        .settings-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 6px;
            width: 36px;
            height: 36px;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            transition: background 0.2s;
        }
        .settings-btn:hover {
            background: rgba(255,255,255,0.3);
        }
        .container { 
            max-width: 600px; 
            margin: 0 auto; 
            padding: 20px 15px;
        }
        .input-group { 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            margin-bottom: 15px; 
        }
        label { 
            font-weight: bold; 
            white-space: nowrap;
            min-width: 70px;
            text-align: right;
        }
        input[type="number"] { 
            width: 100px; 
            padding: 8px; 
            font-size: 16px; 
            border: 2px solid #ccc; 
            border-radius: 6px;
            text-align: center;
            -webkit-appearance: none;
            appearance: none;
        }
        .price-input-container {
            position: relative;
            flex: 1;
            min-width: 0;
        }
        .price-input-container input {
            padding-left: 30px;
        }
        .dollar-sign {
            position: absolute;
            left: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 14px;
            color: #666;
            z-index: 1;
        }
        input[type="text"], input[type="date"], select {
            flex: 1;
            min-width: 0;
            padding: 8px;
            font-size: 16px;
            border: 2px solid #ccc;
            border-radius: 6px;
            -webkit-appearance: none;
            appearance: none;
            box-sizing: border-box;
        }
        .day-toggles {
            display: flex;
            gap: 8px;
            flex: 1;
        }
        .day-btn {
            flex: 1;
            padding: 12px;
            font-size: 14px;
            border: 2px solid #ccc;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            min-height: 44px;
            touch-action: manipulation;
        }
        .day-btn.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }
        .btn-new-session {
            background: #dc3545;
            color: white;
            border: none;
            padding: 12px 20px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
            min-height: 44px;
            flex: 1;
            touch-action: manipulation;
        }
        .btn-load-session {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 8px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
            min-height: 44px;
            flex: 1;
            touch-action: manipulation;
        }
        .btn-load-session.disabled {
            background: #6c757d;
            cursor: not-allowed;
            opacity: 0.6;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 2500;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        .modal-content {
            background-color: white;
            margin: 10% auto;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            max-height: 70vh;
            overflow-y: auto;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #999;
        }
        .session-item {
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 6px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .session-item:hover {
            background-color: #f8f9fa;
        }
        .session-info {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .session-details {
            font-size: 14px;
            color: #666;
        }
        .event-settings {
            background: white;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .settings-header {
            padding: 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #eee;
            font-weight: bold;
        }
        .settings-content {
            padding: 15px;
            display: none;
            overflow: hidden;
        }
        .settings-content.open {
            display: block;
        }
        .collapse-icon {
            font-size: 12px;
            transition: transform 0.2s;
        }
        .collapse-icon.open {
            transform: rotate(180deg);
        }
        .user-section {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .user-section label::before {
            content: '👤 ';
            font-size: 14px;
        }
        .user-section .btn-load-session {
            width: 100%;
            margin-top: 10px;
        }
        .buttons { 
            display: flex; 
            gap: 10px; 
            margin: 20px 0; 
        }
        .btn-create-session {
            background: #28a745;
            color: white;
            border: none;
            padding: 12px 20px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
            min-height: 44px;
            flex: 1;
            touch-action: manipulation;
        }
        .btn-create-session.inactive {
            background: #6c757d;
            cursor: not-allowed;
            opacity: 0.6;
        }
        .required-field {
            border: 2px solid #dc3545 !important;
        }
        .required-group {
            border: 2px solid #dc3545;
            border-radius: 6px;
            padding: 8px;
        }
        .btn-add { 
            flex: 3; 
            background: #28a745; 
            color: white; 
            border: none; 
            padding: 18px; 
            font-size: 18px; 
            border-radius: 8px; 
            cursor: pointer;
            min-height: 60px;
            touch-action: manipulation;
        }
        .btn-remove { 
            flex: 1; 
            background: #dc3545; 
            color: white; 
            border: none; 
            padding: 18px; 
            font-size: 18px; 
            border-radius: 8px; 
            cursor: pointer;
            min-height: 60px;
            touch-action: manipulation;
        }
        .totals { 
            background: white; 
            padding: 15px; 
            border-radius: 8px; 
            margin-bottom: 20px; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .totals-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
            margin-bottom: 10px;
        }
        .totals-table td {
            padding: 6px 8px;
            border-bottom: 1px solid #eee;
        }
        .totals-table td:first-child {
            color: #666;
        }
        .totals-table td:last-child {
            text-align: right;
            font-weight: 500;
        }
        .grand-total {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            color: #28a745;
            padding-top: 8px;
            border-top: 2px solid #28a745;
        }
        .readings-list { 
            background: white; 
            border-radius: 8px; 
            padding: 20px; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .reading-item { 
            display: flex; 
            align-items: flex-start; 
            gap: 15px;
            padding: 15px 0; 
            border-bottom: 2px solid #ddd; 
            min-height: 50px;
        }
        .reading-item:last-child { 
            border-bottom: none; 
        }
        .reading-left {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 120px;
        }
        .reading-right {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .reading-field {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .field-label {
            font-size: 12px;
            color: #666;
            min-width: 45px;
            font-weight: 500;
        }
        .index { font-size: 14px; color: #999; font-weight: bold; }
        .timestamp { font-size: 15px; color: #666; }
        .tip-input { 
            width: 80px !important; 
            padding: 8px 6px 8px 25px !important; 
            font-size: 14px !important; 
            border: 2px solid #ccc !important; 
            background-color: white !important;
            border-radius: 6px !important;
            text-align: center !important;
            -webkit-appearance: none !important;
            appearance: none !important;
            box-sizing: border-box !important;
            min-height: 36px !important;
        }
        .price-input {
            width: 80px !important;
            padding: 8px 6px 8px 25px !important;
            font-size: 14px !important;
            border: 2px solid #ccc !important;
            background-color: white !important;
            border-radius: 6px !important;
            text-align: center !important;
            -webkit-appearance: none !important;
            appearance: none !important;
            box-sizing: border-box !important;
            min-height: 36px !important;
        }
        .field-input-container {
            position: relative;
            flex: 1;
        }
        .field-input-container .dollar-sign {
            position: absolute;
            left: 6px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 12px;
            color: #999;
            z-index: 1;
        }
        .field-button {
            flex: 1;
            padding: 8px 12px;
            font-size: 12px;
            border: 2px solid #ccc;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            min-height: 36px;
            touch-action: manipulation;
        }
        .field-button.selected {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }
        .delete-btn {
            background: #dc3545 !important;
            color: white !important;
            border: none !important;
            padding: 8px 12px !important;
            font-size: 12px !important;
            border-radius: 4px !important;
            cursor: pointer !important;
            min-height: 44px !important;
            min-width: 40px !important;
        }
        .payment-method-btn {
            padding: 8px 12px;
            font-size: 12px;
            border: 2px solid #ccc;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            min-height: 44px;
            touch-action: manipulation;
            flex: 1;
        }
        .payment-method-btn.selected {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }
        .source-btn {
            padding: 8px 12px;
            font-size: 12px;
            border: 2px solid #ccc;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            min-height: 44px;
            touch-action: manipulation;
            flex: 1;
        }
        .source-btn.selected {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }
        .payment-sheet {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            background: white;
            border-radius: 16px 16px 0 0;
            box-shadow: 0 -4px 20px rgba(0,0,0,0.3);
            z-index: 2001;
            animation: slideUpSheet 0.3s ease;
        }
        .payment-sheet-header {
            padding: 20px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .payment-sheet-options {
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        .payment-option {
            padding: 16px;
            border: 2px solid #ccc;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            text-align: center;
            font-size: 14px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
        }
        .payment-option:hover {
            background: #f8f9fa;
        }
        .payment-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
        }
        .session-sheet {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            background: white;
            border-radius: 16px 16px 0 0;
            box-shadow: 0 -4px 20px rgba(0,0,0,0.3);
            z-index: 2001;
            animation: slideUpSheet 0.3s ease;
            max-height: 70vh;
            overflow-y: auto;
        }
        .session-sheet-header {
            padding: 20px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .session-sheet-content {
            padding: 20px;
        }
        .user-btn {
            flex: 2;
            min-width: 0;
            padding: 8px;
            font-size: 16px;
            border: 2px solid #ccc;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            text-align: left;
            -webkit-appearance: none;
            appearance: none;
            box-sizing: border-box;
            min-height: 44px;
            touch-action: manipulation;
        }
        .user-btn.selected {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }
        .user-item {
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 6px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: background-color 0.2s;
            text-align: center;
            font-size: 16px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .user-item:hover {
            background-color: #f8f9fa;
        }
        .btn-add-user {
            background: #28a745;
            color: white;
            border: none;
            padding: 15px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
            width: 100%;
            min-height: 44px;
            margin-top: 10px;
            touch-action: manipulation;
        }
        .timer {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            text-align: center;
        }
        .timer-canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
        }
        .timer-canvas {
            border: none;
            padding: 0;
            margin: 0;
        }
        .timer h3 {
            font-size: 24px;
            margin-bottom: 20px;
        }
        .timer-display {
            font-size: 80px;
            font-weight: bold;
            font-family: monospace;
            margin: 30px 0;
            color: #333;
        }
        .timer-display.blink {
            animation: blink 1s infinite;
        }
        .timer-display.warning {
            animation: warning-blink 0.5s infinite;
        }
        @keyframes blink {
            0%, 50% { opacity: 1; color: #dc3545; }
            51%, 100% { opacity: 0.3; color: #dc3545; }
        }
        @keyframes warning-blink {
            0%, 50% { color: #333; }
            51%, 100% { color: #999; }
        }
        .timer-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            margin-bottom: 15px;
        }
        .timer-input {
            width: 80px;
            padding: 8px;
            font-size: 16px;
            border: 2px solid #ccc;
            border-radius: 6px;
            text-align: center;
            -webkit-appearance: none;
            appearance: none;
        }
        .arrow-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 12px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
            min-height: 44px;
            min-width: 44px;
        }
        .timer-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .timer-btn {
            padding: 12px 20px;
            font-size: 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            min-height: 44px;
            touch-action: manipulation;
        }
        .start-btn { 
            background: #28a745; 
            color: white; 
            flex: 3;
            padding: 24px 32px;
            font-size: 22px;
            font-weight: bold;
            min-height: 70px;
        }
        .pause-btn { background: #ffc107; color: black; }
        .reset-btn { background: #dc3545; color: white; }

        .settings-drawer {
            position: fixed;
            top: 0;
            right: -350px;
            width: 350px;
            height: 100vh;
            background: white;
            box-shadow: -4px 0 20px rgba(0,0,0,0.3);
            z-index: 2000;
            transition: right 0.3s ease;
            overflow-y: auto;
        }
        .settings-drawer.open {
            right: 0;
        }
        .settings-drawer-header {
            padding: 20px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f8f9fa;
        }
        .settings-drawer-content {
            padding: 20px;
        }
        .settings-section {
            margin-bottom: 30px;
        }
        .settings-section h3 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }
        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #f0f0f0;
        }
        .setting-item:last-child {
            border-bottom: none;
        }
        .setting-label {
            font-size: 14px;
            color: #333;
        }
        .setting-description {
            font-size: 12px;
            color: #666;
            margin-top: 2px;
        }
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
            background: #ccc;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }
        .toggle-switch.active {
            background: #28a745;
        }
        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: left 0.3s;
        }
        .toggle-switch.active::after {
            left: 28px;
        }
        .settings-select {
            padding: 6px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
            width: 150px;
            flex: none;
        }
        .settings-button {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            min-height: 36px;
        }
        .settings-button.danger {
            background: #dc3545;
        }
        .settings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1999;
            display: none;
        }
        .settings-overlay.open {
            display: block;
        }
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 12px 20px;
            border-radius: 24px;
            font-size: 14px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: slideUp 0.3s ease;
            min-width: 200px;
            max-width: 90vw;
        }
        .snackbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            width: 100%;
            background: #d1ecf1;
            color: #0c5460;
            padding: 12px 20px;
            font-size: 14px;
            text-align: center;
            z-index: 3000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: slideDown 0.3s ease;
        }
        .snackbar.success {
            background: #d4edda;
            color: #155724;
        }
        .snackbar.error {
            background: #f8d7da;
            color: #721c24;
        }
        .toast.success { background: #28a745; }
        .toast.error { background: #dc3545; }
        .toast-close {
            background: none;
            border: none;
            color: white;
            font-size: 16px;
            cursor: pointer;
            padding: 0;
            margin-left: 10px;
        }
        @keyframes slideUp {
            from { transform: translateX(-50%) translateY(100%); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        @keyframes slideDown {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes slideUpSheet {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }
        .spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-radius: 50%;
            border-top-color: #007bff;
            animation: spin 1s ease-in-out infinite;
            margin: 20px auto;
        }
        .spinner.inline {
            width: 12px;
            height: 12px;
            border: 2px solid #ffffff;
            border-top-color: transparent;
            margin: 0 8px 0 0;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Payment Methods Customization Sheet */
        .payment-methods-sheet {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            background: white;
            border-radius: 16px 16px 0 0;
            box-shadow: 0 -4px 20px rgba(0,0,0,0.3);
            z-index: 2001;
            animation: slideUpSheet 0.3s ease;
            max-height: 70vh;
            overflow-y: auto;
        }
        .payment-method-item {
            display: flex;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #f0f0f0;
            gap: 10px;
        }
        .payment-method-item:last-child {
            border-bottom: none;
        }
        .payment-method-input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 14px;
        }
        .payment-method-delete {
            background: #dc3545;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            min-height: 36px;
        }
        .add-payment-method {
            background: #28a745;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            width: 100%;
            margin-top: 15px;
            min-height: 44px;
        }
        
        /* Dark Mode Styles */
        body.dark-mode {
            background: #1a1a1a;
            color: #ffffff;
        }
        body.dark-mode .container {
            background: #1a1a1a;
        }
        body.dark-mode .event-settings,
        body.dark-mode .totals,
        body.dark-mode .readings-list,
        body.dark-mode .timer {
            background: #2d2d2d;
            color: #ffffff;
        }
        body.dark-mode .settings-header,
        body.dark-mode h3,
        body.dark-mode label {
            color: #ffffff;
        }
        body.dark-mode .timestamp,
        body.dark-mode .session-details {
            color: #cccccc;
        }
        body.dark-mode input,
        body.dark-mode select,
        body.dark-mode .user-btn {
            background: #3d3d3d;
            color: #ffffff;
            border-color: #555;
        }
        body.dark-mode .day-btn {
            background: #3d3d3d;
            color: #ffffff;
            border-color: #555;
        }
        body.dark-mode .settings-drawer {
            background: #2d2d2d;
            color: #ffffff;
        }
        body.dark-mode .settings-drawer-header {
            background: #1a1a1a;
            border-color: #555;
        }
        body.dark-mode .setting-item {
            border-color: #555;
        }
        body.dark-mode .setting-label {
            color: #ffffff;
        }
        body.dark-mode .setting-description {
            color: #cccccc;
        }
        body.dark-mode .modal-content,
        body.dark-mode .payment-methods-sheet {
            background: #2d2d2d;
            color: #ffffff;
        }
        body.dark-mode .payment-method-input {
            background: #3d3d3d;
            color: #ffffff;
            border-color: #555;
        }
        body.dark-mode .session-sheet,
        body.dark-mode .payment-sheet {
            background: #2d2d2d;
            color: #ffffff;
        }
        body.dark-mode .session-info {
            color: #ffffff;
        }
        body.dark-mode .header {
            background: #1a4d2e;
        }
        body.dark-mode .dollar-sign {
            background: #555;
            color: #cccccc;
        }
        body.dark-mode .timer-display {
            color: #f4e4a6 !important;
        }
        
        /* Report Maker Styles */
        .report-preset-btn {
            background: #f8f9fa;
            border: 1px solid #ccc;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .report-preset-btn:hover {
            background: #e9ecef;
        }
        .report-preset-btn.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }
        .report-group {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .report-group-header {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 10px;
            color: #333;
        }
        .report-totals {
            background: #e8f5e8;
            border: 2px solid #28a745;
            border-radius: 6px;
            padding: 15px;
            margin-top: 20px;
        }
        .report-totals h3 {
            margin: 0 0 10px 0;
            color: #28a745;
        }
        .report-session {
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 8px;
        }
        .report-session-header {
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
        }
        .report-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 14px;
        }
        .report-stat {
            display: flex;
            justify-content: space-between;
        }
        .report-totals-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 10px;
        }
        .report-total-item {
            text-align: center;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        body.dark-mode .report-preset-btn {
            background: #3d3d3d;
            color: #ffffff;
            border-color: #555;
        }
        body.dark-mode .report-preset-btn:hover {
            background: #4d4d4d;
        }
        body.dark-mode .report-group {
            background: #2d2d2d;
            border-color: #555;
        }
        body.dark-mode .report-group-header {
            color: #ffffff;
        }
        body.dark-mode .report-totals {
            background: #1a4d2e;
            border-color: #28a745;
        }
        body.dark-mode .report-table th {
            background: #1a1a1a;
            color: #ffffff;
        }
        body.dark-mode .report-table td {
            color: #ffffff;
        }
        
        .btn {
            padding: 12px 20px;
            font-size: 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            min-height: 44px;
            touch-action: manipulation;
        }
        .btn-secondary {
            background: #007bff;
            color: white;
        }
        .btn-secondary:disabled {
            background: #6c757d;
            cursor: not-allowed;
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <header class="header">
        <h1 id="headerTitle">Tarot Reading Tracker</h1>
        <div class="header-actions">
            <span class="version-badge">v3.93.0</span>
            <button class="settings-btn" onclick="openSettingsDrawer()" title="Settings">⚙️</button>
        </div>
    </header>
    <div class="container">
        <div class="event-settings">
            <div class="settings-header" onclick="toggleSettings()">
                <span>Event Settings</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="settings-content" id="settingsContent">
                <div class="user-section">
                    <div class="input-group">
                        <label for="user">User:</label>
                        <button id="userBtn" onclick="showUserSelection()" class="user-btn">Select User...</button>
                    </div>
                    <button class="btn-load-session" onclick="showLoadSession()">Load Session</button>
                </div>

                <hr style="border: none; border-top: 1px solid #ddd; margin: 15px 0;">

                <div class="input-group">
                    <label for="price">Reading<br>Price:</label>
                    <div class="price-input-container">
                        <span class="dollar-sign">$</span>
                        <input type="number" id="price" value="40" step="0.01" min="0">
                    </div>
                </div>

                <div class="input-group">
                    <label for="location">Event<br>Name:</label>
                    <input type="text" id="location" placeholder="(City, Season, Year, etc.)">
                </div>

                <div class="input-group">
                    <label for="sessionDate">Event<br>Date:</label>
                    <input type="date" id="sessionDate" placeholder="Select event date" onclick="this.showPicker()">
                </div>

                <hr style="border: none; border-top: 1px solid #ddd; margin: 15px 0;">

                <div id="requiredFieldsNote" style="font-size: 11px; color: #dc3545; text-align: center; margin-bottom: 10px;">* Fill in the red-outlined fields to create a new session</div>

                <div class="input-group">
                    <button class="btn-create-session inactive" onclick="handleCreateSession()">Create Session</button>
                    <button class="btn-new-session" onclick="startNewSession()" style="display: none;">New Session</button>
                </div>
            </div>
        </div>

        <div class="buttons">
            <button class="btn-add" onclick="addReading()">+ Add Reading</button>
            <button class="btn-remove" onclick="removeReading()">-</button>
        </div>

        <div class="totals">
            <table class="totals-table">
                <tr>
                    <td>Readings:</td>
                    <td><span id="readingCount">0</span></td>
                </tr>
                <tr>
                    <td>Base Total:</td>
                    <td>$<span id="baseTotal">0.00</span></td>
                </tr>
                <tr>
                    <td>Tips Total:</td>
                    <td>$<span id="tipsTotal">0.00</span></td>
                </tr>
            </table>
            <div class="grand-total">Total: $<span id="grandTotal">0.00</span></div>
        </div>

        <div class="readings-list">
            <h3>Readings Log</h3>
            <div id="readingsList"></div>
        </div>

        <div class="timer">
            <h3>Timer</h3>
            <div class="timer-controls">
                <button class="arrow-btn" onclick="adjustTime(-1)">▼</button>
                <input type="number" class="timer-input" id="timerInput" value="15" min="0" max="99" inputmode="numeric">
                <button class="arrow-btn" onclick="adjustTime(1)">▲</button>
            </div>
            <div class="timer-canvas-container">
                <canvas id="timerCanvas" class="timer-canvas" width="300" height="300"></canvas>
            </div>
            <div class="timer-display" id="timerDisplay" style="display: none;">15:00</div>
            <div class="timer-buttons">
                <button class="timer-btn start-btn" onclick="startTimer()">Start</button>
                <button class="timer-btn pause-btn" onclick="pauseTimer()">Pause</button>
                <button class="timer-btn reset-btn" onclick="resetTimer()">Reset</button>
            </div>
        </div>
    </div>

    <!-- Payment Method Sheet -->
    <div id="paymentOverlay" class="payment-overlay" onclick="closePaymentSheet()"></div>
    <div id="paymentSheet" class="payment-sheet">
        <div class="payment-sheet-header">
            <h3>Select Payment Method</h3>
            <button class="modal-close" onclick="closePaymentSheet()">×</button>
        </div>
        <div class="payment-sheet-options" id="paymentOptions">
            <!-- Payment options populated dynamically -->
        </div>
    </div>

    <!-- Source Sheet -->
    <div id="sourceOverlay" class="payment-overlay" onclick="closeSourceSheet()"></div>
    <div id="sourceSheet" class="payment-sheet">
        <div class="payment-sheet-header">
            <h3>Select Source</h3>
            <button class="modal-close" onclick="closeSourceSheet()">×</button>
        </div>
        <div class="payment-sheet-options" id="sourceOptions">
            <!-- Source options populated dynamically -->
        </div>
    </div>

    <!-- User Selection Sheet -->
    <div id="userOverlay" class="payment-overlay" onclick="hideUserSelection()"></div>
    <div id="userSheet" class="session-sheet">
        <div class="session-sheet-header">
            <h3>Select User</h3>
            <button class="modal-close" onclick="hideUserSelection()">&times;</button>
        </div>
        <div class="session-sheet-content">
            <div id="userList"></div>
            <button onclick="addNewUser()" class="btn-add-user">+ Add New User</button>
        </div>
    </div>

    <!-- Load Session Sheet -->
    <div id="sessionOverlay" class="payment-overlay" onclick="closeSessionSheet()"></div>
    <div id="sessionSheet" class="session-sheet">
        <div class="session-sheet-header">
            <h3>Load Existing Session</h3>
            <button class="modal-close" onclick="closeSessionSheet()">×</button>
        </div>
        <div class="session-sheet-content">
            <div id="sessionsList"></div>
        </div>
    </div>

    <!-- Payment Methods Customization Sheet -->
    <div id="paymentMethodsOverlay" class="payment-overlay" onclick="closePaymentMethodsSheet()"></div>
    <div id="paymentMethodsSheet" class="payment-methods-sheet">
        <div class="session-sheet-header">
            <h3>Customize Payment Methods</h3>
            <button class="modal-close" onclick="closePaymentMethodsSheet()">×</button>
        </div>
        <div class="session-sheet-content">
            <div id="paymentMethodsList"></div>
            <button onclick="addPaymentMethod()" class="add-payment-method">+ Add Payment Method</button>
        </div>
    </div>

    <!-- Sources Customization Sheet -->
    <div id="sourcesOverlay" class="payment-overlay" onclick="closeSourcesSheet()"></div>
    <div id="sourcesSheet" class="payment-methods-sheet">
        <div class="session-sheet-header">
            <h3>Customize Sources</h3>
            <button class="modal-close" onclick="closeSourcesSheet()">×</button>
        </div>
        <div class="session-sheet-content">
            <div id="sourcesList"></div>
            <button onclick="addSource()" class="add-payment-method">+ Add Source</button>
        </div>
    </div>

    <!-- Report Maker Modal -->
    <div id="reportModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Generate Report</h2>
                <button class="modal-close" onclick="closeReportMaker()">×</button>
            </div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: bold;">Date Range:</label>
                <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 10px;">
                    <button class="report-preset-btn active" onclick="setDateRange('today')">Today</button>
                    <button class="report-preset-btn" onclick="setDateRange('weekend')">This Weekend</button>
                    <button class="report-preset-btn" onclick="setDateRange('month')">This Month</button>
                    <button class="report-preset-btn" onclick="setDateRange('ytd')">YTD</button>
                    <button class="report-preset-btn" onclick="setDateRange('year')">1 Year</button>
                    <button class="report-preset-btn" onclick="setDateRange('lastYear')">Last Year</button>
                    <button class="report-preset-btn" onclick="setDateRange('all')">All Time</button>
                    <button class="report-preset-btn" onclick="setDateRange('custom')">Custom</button>
                </div>
                <div id="customDateInputs" style="display: none;">
                    <div style="margin-bottom: 8px;">
                        <label style="display: block; font-size: 12px; margin-bottom: 4px; color: #666;">From:</label>
                        <input type="date" id="startDate" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                    </div>
                    <div>
                        <label style="display: block; font-size: 12px; margin-bottom: 4px; color: #666;">To:</label>
                        <input type="date" id="endDate" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                    </div>
                </div>
            </div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: bold;">Group By:</label>
                <select id="groupBy" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                    <option value="location">Location</option>
                    <option value="date">Date</option>
                    <option value="payment">Payment Method</option>
                    <option value="source">Referral Source</option>
                </select>
            </div>
            <div style="display: flex; gap: 10px;">
                <button class="btn btn-secondary" onclick="generateReport()" style="flex: 1;" id="generateBtn">Generate Report</button>
                <button class="btn btn-secondary" onclick="exportReportData()" style="flex: 1;" id="exportBtn" disabled>Export CSV</button>
            </div>
        </div>
    </div>

    <!-- Report Results Modal -->
    <div id="reportResultsModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h2>Report Results</h2>
                <button class="modal-close" onclick="closeReportResults()">×</button>
            </div>
            <div id="reportContent"></div>
            <div style="margin-top: 20px; text-align: center;">
                <button class="btn btn-secondary" onclick="exportReportData()">Export CSV</button>
            </div>
        </div>
    </div>

    <!-- Settings Drawer -->
    <div id="settingsOverlay" class="settings-overlay" onclick="closeSettingsDrawer()"></div>
    <div id="settingsDrawer" class="settings-drawer">
        <div class="settings-drawer-header">
            <h2>Settings</h2>
            <button class="modal-close" onclick="closeSettingsDrawer()">×</button>
        </div>
        <div class="settings-drawer-content">
            <!-- App Preferences -->
            <div class="settings-section">
                <h3>App Preferences</h3>
                <div class="setting-item">
                    <div>
                        <div class="setting-label">Sound Alerts</div>
                        <div class="setting-description">Timer alarm sounds</div>
                    </div>
                    <div class="toggle-switch" id="soundToggle" onclick="toggleSetting('sound')"></div>
                </div>
                <div class="setting-item">
                    <div>
                        <div class="setting-label">Haptic Feedback</div>
                        <div class="setting-description">Vibration on button presses</div>
                    </div>
                    <div class="toggle-switch" id="hapticToggle" onclick="toggleSetting('haptic')"></div>
                </div>
                <div class="setting-item">
                    <div>
                        <div class="setting-label">Timer Notifications</div>
                        <div class="setting-description">Push notifications when timer expires</div>
                    </div>
                    <div class="toggle-switch" id="timerNotificationsToggle" onclick="toggleSetting('timerNotifications')"></div>
                </div>
                <div class="setting-item">
                    <div>
                        <div class="setting-label">Dark Mode</div>
                        <div class="setting-description">Dark theme for evening events</div>
                    </div>
                    <div class="toggle-switch" id="darkModeToggle" onclick="toggleSetting('darkMode')"></div>
                </div>
                <div class="setting-item">
                    <div>
                        <div class="setting-label">Default Timer</div>
                        <div class="setting-description">Default timer duration</div>
                    </div>
                    <select class="settings-select" id="defaultTimer" onchange="updateSetting('defaultTimer', this.value)">
                        <option value="5">5 minutes</option>
                        <option value="10">10 minutes</option>
                        <option value="15" selected>15 minutes</option>
                        <option value="20">20 minutes</option>
                        <option value="30">30 minutes</option>
                    </select>
                </div>
            </div>

            <!-- Payment Methods -->
            <div class="settings-section">
                <h3>Payment Methods</h3>
                <div class="setting-item">
                    <div>
                        <div class="setting-label">Available Methods</div>
                        <div class="setting-description">Customize payment options</div>
                    </div>
                    <button class="settings-button" onclick="customizePaymentMethods()">Customize</button>
                </div>
            </div>

            <!-- Sources -->
            <div class="settings-section">
                <h3>Sources</h3>
                <div class="setting-item">
                    <div>
                        <div class="setting-label">Available Sources</div>
                        <div class="setting-description">Customize source options</div>
                    </div>
                    <button class="settings-button" onclick="customizeSources()">Customize</button>
                </div>
            </div>

            <!-- Data & Export -->
            <div class="settings-section">
                <h3>Data & Export</h3>
                <div class="setting-item">
                    <div>
                        <div class="setting-label">Generate Report</div>
                        <div class="setting-description">Create summary reports with grouping and totals</div>
                    </div>
                    <button class="settings-button" onclick="showReportMaker()">Report</button>
                </div>
                <div class="setting-item">
                    <div>
                        <div class="setting-label">Export Data</div>
                        <div class="setting-description">Download session data as CSV</div>
                    </div>
                    <button class="settings-button" onclick="exportData()">Export</button>
                </div>

            </div>

            <!-- Analytics -->
            <div class="settings-section">
                <h3>Analytics & Notifications</h3>
                <div class="setting-item">
                    <div>
                        <div class="setting-label">Daily Summary</div>
                        <div class="setting-description">End of day notifications</div>
                    </div>
                    <div class="toggle-switch" id="dailySummaryToggle" onclick="toggleSetting('dailySummary')"></div>
                </div>
                <div class="setting-item">
                    <div>
                        <div class="setting-label">Weekend Goals</div>
                        <div class="setting-description">Earnings milestone alerts</div>
                    </div>
                    <div class="toggle-switch" id="weekendGoalsToggle" onclick="toggleSetting('weekendGoals')"></div>
                </div>
                <div class="setting-item">
                    <div>
                        <div class="setting-label">Best Day Alerts</div>
                        <div class="setting-description">Peak performance notifications</div>
                    </div>
                    <div class="toggle-switch" id="bestDayToggle" onclick="toggleSetting('bestDay')"></div>
                </div>
                <div class="setting-item">
                    <div>
                        <div class="setting-label">Tip Trends</div>
                        <div class="setting-description">Tip analysis notifications</div>
                    </div>
                    <div class="toggle-switch" id="tipTrendsToggle" onclick="toggleSetting('tipTrends')"></div>
                </div>
                <div class="setting-item">
                    <div>
                        <div class="setting-label">Peak Time Alerts</div>
                        <div class="setting-description">Busy time notifications</div>
                    </div>
                    <div class="toggle-switch" id="peakTimeToggle" onclick="toggleSetting('peakTime')"></div>
                </div>
            </div>

            <!-- App Updates -->
            <div class="settings-section">
                <h3>App Updates</h3>
                <div class="setting-item">
                    <div>
                        <div class="setting-label">Check for Updates</div>
                        <div class="setting-description">Manually check for new app versions</div>
                    </div>
                    <button class="settings-button" onclick="checkForUpdates()">Check</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <script>
        // Supabase configuration
        const SUPABASE_URL = 'https://uuindvqgdblkjzvjsyrz.supabase.co';
        const SUPABASE_ANON_KEY = 'sb_publishable_MsdJm2VITIPWik4dBPErrw_QjfIsKe9';
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // Service worker registration for PWA with message handling
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/serviceWorker.js')
                .then(registration => {
                    // Check for updates
                    registration.addEventListener('updatefound', () => {
                        const newWorker = registration.installing;
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                showUpdateNotification();
                            }
                        });
                    });
                    
                    // Register for periodic background sync (requires user permission)
                    if ('periodicSync' in window.ServiceWorkerRegistration.prototype) {
                        registration.periodicSync.register('backup-readings', {
                            minInterval: 24 * 60 * 60 * 1000 // 24 hours
                        }).catch(() => {});
                    }
                    
                    // Request notification permission
                    if ('Notification' in window && 'serviceWorker' in navigator) {
                        Notification.requestPermission();
                    }
                })
                .catch(() => {});
            
            // Listen for messages from service worker
            navigator.serviceWorker.addEventListener('message', event => {
                if (event.data.type === 'SYNC_READINGS') {
                    handleBackgroundSync();
                } else if (event.data.type === 'BACKUP_READINGS') {
                    handleBackgroundBackup();
                } else if (event.data.type === 'RESET_TIMER') {
                    handleTimerReset();
                }
            });
            
            // Handle timer reset from notification
            function handleTimerReset() {
                timer.reset(true);
            }
        }

        
        // Central Session Store
        class SessionStore {
            constructor() {
                this._sessionId = null;
                this._user = '';
                this._location = '';
                this._sessionDate = '';
                this._price = 40;
                this._readings = [];
                this.saveTimeout = null;
                this._loading = false;
            }

            // Getters
            get sessionId() { return this._sessionId; }
            get user() { return this._user; }
            get location() { return this._location; }
            get sessionDate() { return this._sessionDate; }
            get price() { return this._price; }
            get readings() { return this._readings; }

            // Computed properties
            get canCreateSession() {
                return this._user.trim() && this._location.trim() && this._sessionDate && this._price;
            }
            get hasValidSession() {
                return this._sessionId && this._user.trim() && this._location.trim() && this._sessionDate;
            }
            get sessionPhase() {
                if (this.hasValidSession) return 'ACTIVE';
                if (this.canCreateSession) return 'READY_TO_CREATE';
                return 'SETUP';
            }

            // Setters with side effects
            set sessionId(value) {
                this._sessionId = value;
                this.updateUI();
                this.save();
            }
            set user(value) {
                const wasActiveSession = this.hasValidSession;
                const previousUser = this._user;
                
                this._user = value;
                const userBtn = document.getElementById('userBtn');
                userBtn.textContent = value || 'Select User...';
                userBtn.classList.toggle('selected', !!value);
                
                // If switching users during active session, clear session
                if (wasActiveSession && previousUser && previousUser !== value) {
                    this._sessionId = null;
                    this._location = '';
                    this._sessionDate = '';
                    this._price = 40;
                    this._readings = [];
                    document.getElementById('location').value = '';
                    document.getElementById('price').value = '40';
                    document.getElementById('sessionDate').value = '';
                    this.updateReadingsList();
                    this.updateTotals();
                    showSnackbar(`Switched to ${value}. Ready to create new session or load existing.`, 'success');
                }
                
                this.updateUI();
                this.debouncedSave();
            }
            set location(value) {
                this._location = value;
                document.getElementById('location').value = value;
                this.updateUI();
                this.debouncedSave();
            }
            set sessionDate(value) {
                this._sessionDate = value;
                document.getElementById('sessionDate').value = value;
                this.updateUI();
                this.debouncedSave();
            }
            set price(value) {
                this._price = value;
                document.getElementById('price').value = value;
                this.updateUI();
                this.debouncedSave();
            }
            set readings(value) {
                this._readings = value;
                this.migrateTimestamps();
                this.updateReadingsList();
                this.updateTotals();
                this.save();
            }

            // Methods
            addReading(reading) {
                this._readings.push(reading);
                this.updateReadingsList();
                this.updateTotals();
                this.save();
            }
            removeReading(index) {
                this._readings.splice(index, 1);
                this.updateReadingsList();
                this.updateTotals();
                this.save();
            }
            updateReading(index, field, value) {
                this._readings[index][field] = value;
                this.updateReadingsList();
                this.updateTotals();
                this.debouncedSave();
            }

            startOver() {
                this._sessionId = null;
                this._location = '';
                this._sessionDate = '';
                this._price = 40;
                this._readings = [];
                document.getElementById('location').value = '';
                document.getElementById('price').value = '40';
                document.getElementById('sessionDate').value = '';
                this.clearUserData();
                this.updateUI();
            }

            clear() {
                this.startOver();
            }

            updateUI() {
                this.updateButtons();
                this.updateSections();
            }

            updateButtons() {
                const createBtn = document.querySelector('.btn-create-session');
                const newBtn = document.querySelector('.btn-new-session');
                const loadBtn = document.querySelector('.btn-load-session');
                const locationInput = document.getElementById('location');
                const sessionDateInput = document.getElementById('sessionDate');
                const requiredNote = document.getElementById('requiredFieldsNote');
                
                // Load Session button - disabled if no user
                if (loadBtn) {
                    if (!this._user.trim()) {
                        loadBtn.classList.add('disabled');
                        loadBtn.disabled = true;
                    } else {
                        loadBtn.classList.remove('disabled');
                        loadBtn.disabled = false;
                    }
                }
                
                // Create Session button - only visible in setup phase
                if (this.sessionPhase === 'SETUP' || this.sessionPhase === 'READY_TO_CREATE') {
                    createBtn.style.display = 'block';
                    if (this.sessionPhase === 'READY_TO_CREATE') {
                        createBtn.classList.remove('inactive');
                        createBtn.classList.add('active');
                    } else {
                        createBtn.classList.remove('active');
                        createBtn.classList.add('inactive');
                    }
                } else {
                    createBtn.style.display = 'none';
                }
                
                // Show/hide required fields note
                if (requiredNote) {
                    requiredNote.style.display = this.sessionPhase === 'SETUP' ? 'block' : 'none';
                }
                
                // Highlight required fields and auto-expand when in setup mode
                if (this.sessionPhase === 'SETUP') {
                    // Auto-expand settings panel
                    const content = document.getElementById('settingsContent');
                    const icon = document.querySelector('.collapse-icon');
                    if (!content.classList.contains('open')) {
                        content.classList.add('open');
                        icon.classList.add('open');
                    }
                    
                    const userBtn = document.getElementById('userBtn');
                    if (!this._user.trim()) {
                        userBtn.classList.add('required-field');
                    } else {
                        userBtn.classList.remove('required-field');
                    }
                    
                    if (!this._location.trim()) {
                        locationInput.classList.add('required-field');
                    } else {
                        locationInput.classList.remove('required-field');
                    }
                    
                    if (!this._sessionDate) {
                        sessionDateInput.classList.add('required-field');
                    } else {
                        sessionDateInput.classList.remove('required-field');
                    }
                } else {
                    const userBtn = document.getElementById('userBtn');
                    userBtn.classList.remove('required-field');
                    locationInput.classList.remove('required-field');
                    sessionDateInput.classList.remove('required-field');
                }
                
                // New Session button - only show when session is active
                newBtn.style.display = this.sessionPhase === 'ACTIVE' ? 'block' : 'none';
                
                // Auto-expand settings when create button becomes ready
                if (this.sessionPhase === 'READY_TO_CREATE') {
                    const content = document.getElementById('settingsContent');
                    const icon = document.querySelector('.collapse-icon');
                    if (!content.classList.contains('open')) {
                        content.classList.add('open');
                        icon.classList.add('open');
                    }
                }
            }

            updateSections() {
                const buttonsDiv = document.querySelector('.buttons');
                const totalsDiv = document.querySelector('.totals');
                const readingsDiv = document.querySelector('.readings-list');
                
                const showSections = this.sessionPhase === 'ACTIVE';
                buttonsDiv.style.display = showSections ? 'flex' : 'none';
                totalsDiv.style.display = showSections ? 'block' : 'none';
                readingsDiv.style.display = showSections ? 'block' : 'none';
            }

            updateReadingsList() {
                const list = document.getElementById('readingsList');
                list.innerHTML = this._readings.map((reading, index) => {
                    const displayTime = this.formatTimestamp(reading.timestamp);
                    return `
                    <div class="reading-item" data-index="${index}">
                        <div class="reading-left">
                            <button class="delete-btn" onclick="deleteReading(${index})">×</button>
                            <div style="border-left: 2px solid #ddd; padding-left: 10px;">
                                <span class="index">${index + 1}.</span>
                                <span class="timestamp">${displayTime}</span>
                            </div>
                        </div>
                        <div class="reading-right">
                            <div class="reading-field">
                                <span class="field-label">Price:</span>
                                <div class="field-input-container">
                                    <span class="dollar-sign">$</span>
                                    <input type="number" class="price-input" placeholder="${this._price}" 
                                           value="${reading.price || ''}" step="0.01" min="0" inputmode="decimal"
                                           onchange="session.updateReading(${index}, 'price', parseFloat(this.value) || null)"
                                           onkeydown="if(event.key==='Enter') this.blur()">
                                </div>
                            </div>
                            <div class="reading-field">
                                <span class="field-label">Tip:</span>
                                <div class="field-input-container">
                                    <span class="dollar-sign">$</span>
                                    <input type="number" class="tip-input" placeholder="0" 
                                           value="${reading.tip || ''}" step="0.01" min="0" inputmode="decimal"
                                           onchange="session.updateReading(${index}, 'tip', parseFloat(this.value) || 0)"
                                           onkeydown="if(event.key==='Enter') this.blur()">
                                </div>
                            </div>
                            <div class="reading-field">
                                <span class="field-label">Pay:</span>
                                <button class="field-button ${reading.payment ? 'selected' : ''}" 
                                        onclick="openPaymentSheet(${index})">
                                    ${reading.payment || 'Method'}
                                </button>
                            </div>
                            <div class="reading-field">
                                <span class="field-label">From:</span>
                                <button class="field-button ${reading.source ? 'selected' : ''}" 
                                        onclick="openSourceSheet(${index})">
                                    ${reading.source || 'Source'}
                                </button>
                            </div>
                        </div>
                    </div>
                `}).join('');
            }

            formatTimestamp(timestamp) {
                if (!timestamp) return '';
                if (timestamp.includes('T')) {
                    return new Date(timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                }
                return timestamp; // Legacy format
            }

            async migrateTimestamps() {
                if (!this._sessionId || !this._readings.length) return;
                
                let needsMigration = false;
                let sessionDate = new Date().toISOString().split('T')[0]; // Fallback to today
                
                // Try to get actual session date from database
                try {
                    const { data } = await supabase
                        .from('blacksheep_reading_tracker_sessions')
                        .select('session_date')
                        .eq('id', this._sessionId)
                        .single();
                    if (data && data.session_date) {
                        sessionDate = data.session_date;
                    }
                } catch (error) {
                    // Use fallback date
                }
                
                this._readings.forEach(reading => {
                    if (!reading.timestamp.includes('T')) {
                        needsMigration = true;
                        const timeMatch = reading.timestamp.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i);
                        if (timeMatch) {
                            let hour = parseInt(timeMatch[1]);
                            const minute = parseInt(timeMatch[2]);
                            const period = timeMatch[3].toUpperCase();
                            
                            if (period === 'PM' && hour !== 12) hour += 12;
                            if (period === 'AM' && hour === 12) hour = 0;
                            
                            const fullDate = new Date(sessionDate);
                            fullDate.setHours(hour, minute, 0, 0);
                            reading.timestamp = fullDate.toISOString();
                        }
                    }
                });
                
                if (needsMigration) {
                    this.save();
                }
            }

            updateTotals() {
                const count = this._readings.length;
                const baseTotal = this._readings.reduce((sum, reading) => sum + (reading.price || this._price), 0);
                const tipsTotal = this._readings.reduce((sum, reading) => sum + (reading.tip || 0), 0);
                const grandTotal = baseTotal + tipsTotal;

                document.getElementById('readingCount').textContent = count;
                document.getElementById('baseTotal').textContent = baseTotal.toFixed(2);
                document.getElementById('tipsTotal').textContent = tipsTotal.toFixed(2);
                document.getElementById('grandTotal').textContent = grandTotal.toFixed(2);
            }

            async save() {
                if (!this._user || this._loading) return; // Don't save without user or during loading
                
                const state = {
                    sessionId: this._sessionId,
                    user: this._user,
                    location: this._location,
                    sessionDate: this._sessionDate,
                    price: this._price,
                    readings: this._readings
                };
                localStorage.setItem(`readingTracker_${this._user}`, JSON.stringify(state));

                if (this._sessionId) {
                    try {
                        const updateData = {
                            user_name: this._user,
                            location: this._location,
                            reading_price: this._price,
                            readings: this._readings
                        };
                        
                        // Only include session_date if it's not empty
                        if (this._sessionDate && this._sessionDate.trim()) {
                            updateData.session_date = this._sessionDate;
                        }
                        
                        await supabase
                            .from('blacksheep_reading_tracker_sessions')
                            .update(updateData)
                            .eq('id', this._sessionId);
                    } catch (error) {
                        console.error('Supabase update error:', error);
                        console.error('Error details:', error.details, error.hint, error.code);
                        console.error('Data being sent:', {
                            user_name: this._user,
                            location: this._location,
                            session_date: this._sessionDate,
                            reading_price: this._price,
                            readings: this._readings
                        });
                        // Register for background sync on network failure
                        registerBackgroundSync();
                    }
                }
            }

            debouncedSave() {
                clearTimeout(this.saveTimeout);
                this.saveTimeout = setTimeout(() => this.save(), 500);
            }

            loadFromStorage() {
                if (!this._user) return;
                
                const saved = localStorage.getItem(`readingTracker_${this._user}`);
                if (saved) {
                    const state = JSON.parse(saved);
                    this._sessionId = state.sessionId || null;
                    this._location = state.location || '';
                    this._sessionDate = state.sessionDate || state.selectedDay || '';
                    this._price = state.price || 40;
                    this._readings = state.readings || [];
                    
                    // Update DOM without triggering saves
                    const userBtn = document.getElementById('userBtn');
                    userBtn.textContent = this._user || 'Select User...';
                    userBtn.classList.toggle('selected', !!this._user);
                    document.getElementById('location').value = this._location;
                    document.getElementById('price').value = this._price;
                    document.getElementById('sessionDate').value = this._sessionDate;
                    
                    // Update readings display and totals
                    this.updateReadingsList();
                    this.updateTotals();
                    this.updateUI();
                }
            }
            
            async loadUsers() {
                try {
                    const { data } = await supabase
                        .from('blacksheep_reading_tracker_sessions')
                        .select('user_name')
                        .not('user_name', 'is', null);
                    
                    const uniqueUsers = [...new Set(data?.map(row => row.user_name) || [])];
                    const userList = document.getElementById('userList');
                    if (userList) {
                        userList.innerHTML = uniqueUsers.map(user => `
                            <div class="user-item" onclick="selectUser('${user}')">${user}</div>
                        `).join('');
                    }
                    return uniqueUsers;
                } catch (error) {
                    return [];
                }
            }
            
            clearUserData() {
                if (this._user) {
                    localStorage.removeItem(`readingTracker_${this._user}`);
                }
            }
        }

        // Timer class for encapsulating timer functionality
        class Timer {
            constructor() {
                this._seconds = 900; // 15 minutes default
                this._totalSeconds = 900;
                this._isRunning = false;
                this._isBlinking = false;
                this._interval = null;
                this._alarmInterval = null;
                this._canvasAnimationId = null;
                this._wakeLock = null;
                this._silentAudio = null;
                this._canvas = null;
                this._ctx = null;
            }

            // Getters
            get seconds() { return this._seconds; }
            get totalSeconds() { return this._totalSeconds; }
            get isRunning() { return this._isRunning; }
            get isBlinking() { return this._isBlinking; }
            get canvas() { return this._canvas; }
            get ctx() { return this._ctx; }

            // Setters
            set seconds(value) {
                this._seconds = value;
                this.updateDisplay();
            }

            // Methods
            start() {
                vibrate([80]);
                if (!this._isRunning && this._seconds > 0) {
                    this._isRunning = true;
                    this._totalSeconds = this._seconds;
                    this.stopBlinking();
                    this.requestWakeLock();
                    
                    if (this._canvas) {
                        this.drawTimer();
                    }
                    
                    this._interval = setInterval(() => {
                        this._seconds--;
                        this.updateDisplay();
                        
                        if (this._seconds === 10) {
                            this.startWarningBlink();
                        }
                        
                        if (this._seconds <= 0) {
                            this.pause();
                            this.stopWarningBlink();
                            this.startBlinking();
                            this.startAlarm();
                            sendTimerNotification();
                        }
                    }, 1000);
                }
            }

            pause() {
                vibrate([50]);
                this._isRunning = false;
                this.releaseWakeLock();
                
                if (this._canvasAnimationId) {
                    cancelAnimationFrame(this._canvasAnimationId);
                    this._canvasAnimationId = null;
                }
                
                if (this._interval) {
                    clearInterval(this._interval);
                    this._interval = null;
                }
            }

            reset(showToast = false) {
                vibrate([100]);
                this.pause();
                this.stopBlinking();
                this.stopWarningBlink();
                this.stopAlarm();
                this.releaseWakeLock();
                const minutes = parseInt(document.getElementById('timerInput').value);
                this._seconds = minutes * 60;
                this._totalSeconds = this._seconds;
                this.updateDisplay();
                
                if (showToast) {
                    showSnackbar(`Timer reset to ${minutes} minutes`, 'success');
                }
            }

            adjustTime(minutes) {
                vibrate([30]);
                if (!this._isRunning) {
                    const input = document.getElementById('timerInput');
                    let newValue = parseInt(input.value) + minutes;
                    if (newValue < 0) newValue = 0;
                    if (newValue > 99) newValue = 99;
                    input.value = newValue;
                    this._seconds = newValue * 60;
                    this.updateDisplay();
                }
            }

            updateDisplay() {
                const minutes = Math.floor(this._seconds / 60);
                const seconds = this._seconds % 60;
                document.getElementById('timerDisplay').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                if (this._canvas) {
                    this.drawTimer();
                }
            }

            startBlinking() {
                this._isBlinking = true;
                document.getElementById('timerDisplay').classList.add('blink');
            }

            stopBlinking() {
                this._isBlinking = false;
                document.getElementById('timerDisplay').classList.remove('blink');
            }

            startWarningBlink() {
                document.getElementById('timerDisplay').classList.add('warning');
            }

            stopWarningBlink() {
                document.getElementById('timerDisplay').classList.remove('warning');
            }

            startAlarm() {
                playAlarmSequence();
                this._alarmInterval = setInterval(() => {
                    playAlarmSequence();
                }, 1500);
            }

            stopAlarm() {
                if (this._alarmInterval) {
                    clearInterval(this._alarmInterval);
                    this._alarmInterval = null;
                }
            }

            async requestWakeLock() {
                try {
                    if ('wakeLock' in navigator) {
                        this._wakeLock = await navigator.wakeLock.request('screen');
                    }
                } catch (err) {}
                
                try {
                    initAudio();
                    const buffer = audioContext.createBuffer(1, 1, 22050);
                    this._silentAudio = audioContext.createBufferSource();
                    this._silentAudio.buffer = buffer;
                    this._silentAudio.loop = true;
                    const gainNode = audioContext.createGain();
                    this._silentAudio.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    gainNode.gain.setValueAtTime(0.001, audioContext.currentTime);
                    this._silentAudio.start();
                } catch (audioErr) {}
            }

            releaseWakeLock() {
                if (this._wakeLock) {
                    this._wakeLock.release();
                    this._wakeLock = null;
                }
                if (this._silentAudio) {
                    this._silentAudio.stop();
                    this._silentAudio = null;
                }
            }

            initCanvas() {
                this._canvas = document.getElementById('timerCanvas');
                this._ctx = this._canvas.getContext('2d');
                this._ctx.imageSmoothingEnabled = false;
                this.drawTimer();
            }

            drawTimer() {
                if (!this._ctx) return;
                
                const centerX = 150;
                const centerY = 150;
                const radius = 120;
                
                this._ctx.clearRect(0, 0, 300, 300);
                
                // Background circle
                this._ctx.beginPath();
                this._ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                this._ctx.strokeStyle = '#e0e0e0';
                this._ctx.lineWidth = 12;
                this._ctx.stroke();
                
                // Progress arc
                if (this._isRunning) {
                    const progress = this._seconds / this._totalSeconds;
                    if (progress > 0) {
                        this._ctx.beginPath();
                        this._ctx.arc(centerX, centerY, radius, -Math.PI/2, -Math.PI/2 + (2 * Math.PI * progress));
                        
                        const red = Math.round(220 * (1 - progress) + 40 * progress);
                        const green = Math.round(167 * progress + 53 * (1 - progress));
                        const blue = Math.round(69 * (1 - progress));
                        this._ctx.strokeStyle = `rgb(${red}, ${green}, ${blue})`;
                        
                        this._ctx.lineWidth = 12;
                        this._ctx.lineCap = 'round';
                        this._ctx.stroke();
                    }
                } else {
                    this._ctx.beginPath();
                    this._ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                    this._ctx.strokeStyle = '#28a745';
                    this._ctx.lineWidth = 12;
                    this._ctx.stroke();
                }
                
                // Time text
                const minutes = Math.floor(this._seconds / 60);
                const seconds = this._seconds % 60;
                const timeText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                if (this._isRunning) {
                    const progress = this._seconds / this._totalSeconds;
                    const red = Math.round(51 * (1 - progress) + 220 * (1 - progress));
                    const green = Math.round(51 * progress + 53 * (1 - progress));
                    const blue = Math.round(51 * (1 - progress));
                    this._ctx.fillStyle = `rgb(${red}, ${green}, ${blue})`;
                } else {
                    this._ctx.fillStyle = document.body.classList.contains('dark-mode') ? '#f4e4a6' : '#333';
                }
                this._ctx.font = 'bold 72px monospace';
                this._ctx.textAlign = 'center';
                this._ctx.textBaseline = 'middle';
                this._ctx.fillText(timeText, centerX, centerY);
                
                if (this._isRunning) {
                    this._canvasAnimationId = requestAnimationFrame(() => this.drawTimer());
                }
            }
        }

        // Settings Store
        class SettingsStore {
            constructor() {
                this.defaults = {
                    sound: true,
                    haptic: true,
                    darkMode: false,
                    defaultTimer: 15,
                    timerNotifications: true,
                    dailySummary: true,
                    weekendGoals: true,
                    bestDay: true,
                    tipTrends: true,
                    peakTime: true,
                    paymentMethods: ['Cash', 'CC', 'Venmo', 'PayPal', 'Cash App'],
                    sources: ['Referral', 'Renu', 'POG', 'Repeat']
                };
                this.settings = this.loadSettings();
                this.applySettings();
            }

            loadSettings() {
                const saved = localStorage.getItem('tarotTrackerSettings');
                return saved ? { ...this.defaults, ...JSON.parse(saved) } : { ...this.defaults };
            }

            saveSettings() {
                localStorage.setItem('tarotTrackerSettings', JSON.stringify(this.settings));
            }

            get(key) {
                return this.settings[key];
            }

            set(key, value) {
                this.settings[key] = value;
                this.saveSettings();
                this.applySettings();
            }

            toggle(key) {
                this.set(key, !this.get(key));
            }

            applySettings() {
                // Apply dark mode
                if (this.get('darkMode')) {
                    document.body.classList.add('dark-mode');
                } else {
                    document.body.classList.remove('dark-mode');
                }

                // Redraw timer canvas for color changes
                if (window.timer && window.timer.canvas) {
                    window.timer.drawTimer();
                }

                // Update UI toggles
                this.updateToggleUI();
            }

            updateToggleUI() {
                const toggles = {
                    'soundToggle': 'sound',
                    'hapticToggle': 'haptic',
                    'darkModeToggle': 'darkMode',
                    'timerNotificationsToggle': 'timerNotifications',
                    'dailySummaryToggle': 'dailySummary',
                    'weekendGoalsToggle': 'weekendGoals',
                    'bestDayToggle': 'bestDay',
                    'tipTrendsToggle': 'tipTrends',
                    'peakTimeToggle': 'peakTime'
                };

                Object.entries(toggles).forEach(([elementId, settingKey]) => {
                    const element = document.getElementById(elementId);
                    if (element) {
                        element.classList.toggle('active', this.get(settingKey));
                    }
                });

                // Update default timer select
                const timerSelect = document.getElementById('defaultTimer');
                if (timerSelect) {
                    timerSelect.value = this.get('defaultTimer');
                }
            }
        }

        // Date normalization utility
        function normalizeDate(dateStr) {
            if (!dateStr) return null;
            // Convert YYYY-MM-DD or YY-MM-DD to MM/DD/YYYY
            if (dateStr.match(/^\d{2,4}-\d{2}-\d{2}$/)) {
                let [year, month, day] = dateStr.split('-');
                if (year.length === 2) year = '20' + year;
                return `${parseInt(month)}/${parseInt(day)}/${year}`;
            }
            return dateStr; // Already in MM/DD/YYYY or other format
        }

        // Initialize stores
        const settings = new SettingsStore();
        const session = new SessionStore();
        const timer = new Timer();
        
        // Make timer globally accessible for settings
        window.timer = timer;
        
        // Analytics & Notification System
        class AnalyticsNotifier {
            constructor() {
                this.lastNotificationCheck = localStorage.getItem('lastNotificationCheck') || null;
            }
            
            async checkAndSendNotifications() {
                const today = new Date().toDateString();
                if (this.lastNotificationCheck === today) return;
                
                const sessions = await this.getRecentSessions();
                if (!sessions.length) return;
                
                // Daily summary (only if activity today)
                this.checkDailySummary(sessions, today);
                
                // Weekend goals (only on weekends with activity)
                this.checkWeekendGoals(sessions);
                
                // Best day alert (weekly check)
                this.checkBestDay(sessions);
                
                // Tip trends (weekly check)
                this.checkTipTrends(sessions);
                
                // Peak time alerts (after 3+ sessions)
                this.checkPeakTimes(sessions);
                
                this.lastNotificationCheck = today;
                localStorage.setItem('lastNotificationCheck', today);
            }
            
            async getRecentSessions() {
                try {
                    const thirtyDaysAgo = new Date();
                    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
                    
                    const { data } = await supabase
                        .from('blacksheep_reading_tracker_sessions')
                        .select('*')
                        .gte('session_date', thirtyDaysAgo.toISOString().split('T')[0])
                        .order('session_date', { ascending: false });
                    
                    return data || [];
                } catch (error) {
                    return [];
                }
            }
            
            checkDailySummary(sessions, today) {
                if (!settings.get('dailySummary')) return;
                
                const todaySessions = sessions.filter(s => 
                    new Date(s.session_date).toDateString() === today && 
                    s.readings && s.readings.length > 0
                );
                
                if (todaySessions.length === 0) return;
                
                const totalReadings = todaySessions.reduce((sum, s) => sum + (s.readings?.length || 0), 0);
                const totalEarnings = todaySessions.reduce((sum, s) => {
                    const baseTotal = (s.readings?.length || 0) * (s.reading_price || 40);
                    const tipsTotal = s.readings?.reduce((tipSum, r) => tipSum + (r.tip || 0), 0) || 0;
                    return sum + baseTotal + tipsTotal;
                }, 0);
                
                if (totalReadings > 0) {
                    this.sendNotification(
                        'Daily Summary 📊',
                        `Today: ${totalReadings} readings, $${totalEarnings.toFixed(2)} earned!`
                    );
                }
            }
            
            checkWeekendGoals(sessions) {
                if (!settings.get('weekendGoals')) return;
                
                const today = new Date();
                const isWeekend = today.getDay() === 0 || today.getDay() === 6; // Sunday or Saturday
                if (!isWeekend) return;
                
                const weekendSessions = sessions.filter(s => {
                    const sessionDate = new Date(s.session_date);
                    const dayOfWeek = sessionDate.getDay();
                    return (dayOfWeek === 0 || dayOfWeek === 6) && s.readings && s.readings.length > 0;
                });
                
                if (weekendSessions.length === 0) return;
                
                const currentWeekend = weekendSessions.filter(s => {
                    const sessionDate = new Date(s.session_date);
                    const startOfWeekend = new Date(today);
                    startOfWeekend.setDate(today.getDate() - (today.getDay() === 0 ? 1 : today.getDay() - 6));
                    return sessionDate >= startOfWeekend;
                });
                
                const totalReadings = currentWeekend.reduce((sum, s) => sum + (s.readings?.length || 0), 0);
                const totalEarnings = currentWeekend.reduce((sum, s) => {
                    const baseTotal = (s.readings?.length || 0) * (s.reading_price || 40);
                    const tipsTotal = s.readings?.reduce((tipSum, r) => tipSum + (r.tip || 0), 0) || 0;
                    return sum + baseTotal + tipsTotal;
                }, 0);
                
                // Earnings goals
                if (totalEarnings >= 500 && totalEarnings < 1000) {
                    this.sendNotification('Weekend Goal 🎯', `$${totalEarnings.toFixed(2)} earned! $${(1000 - totalEarnings).toFixed(2)} to reach $1000 goal!`);
                } else if (totalEarnings >= 1000) {
                    this.sendNotification('Weekend Goal Crushed! 🚀', `Amazing! $${totalEarnings.toFixed(2)} earned this weekend!`);
                }
                
                // Reading count goals
                if (totalReadings >= 10 && totalReadings < 15) {
                    this.sendNotification('Reading Goal 📚', `${totalReadings} readings done! ${15 - totalReadings} more to reach 15!`);
                } else if (totalReadings >= 15) {
                    this.sendNotification('Reading Goal Achieved! ⭐', `Fantastic! ${totalReadings} readings this weekend!`);
                }
            }
            
            checkBestDay(sessions) {
                if (!settings.get('bestDay')) return;
                
                const dayEarnings = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [] };
                const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                
                sessions.forEach(s => {
                    if (!s.readings || s.readings.length === 0) return;
                    const dayOfWeek = new Date(s.session_date).getDay();
                    const baseTotal = s.readings.length * (s.reading_price || 40);
                    const tipsTotal = s.readings.reduce((sum, r) => sum + (r.tip || 0), 0);
                    dayEarnings[dayOfWeek].push(baseTotal + tipsTotal);
                });
                
                let bestDay = null;
                let bestAverage = 0;
                
                Object.keys(dayEarnings).forEach(day => {
                    const earnings = dayEarnings[day];
                    if (earnings.length >= 2) {
                        const average = earnings.reduce((sum, e) => sum + e, 0) / earnings.length;
                        if (average > bestAverage) {
                            bestAverage = average;
                            bestDay = parseInt(day);
                        }
                    }
                });
                
                if (bestDay !== null) {
                    this.sendNotification(
                        'Best Day Alert 📈',
                        `${dayNames[bestDay]} is your highest earning day - $${bestAverage.toFixed(2)} average!`
                    );
                }
            }
            
            checkTipTrends(sessions) {
                if (!settings.get('tipTrends')) return;
                
                const recentSessions = sessions.slice(0, 10);
                const olderSessions = sessions.slice(10, 20);
                
                if (recentSessions.length < 3 || olderSessions.length < 3) return;
                
                const recentAvgTip = this.calculateAverageTip(recentSessions);
                const olderAvgTip = this.calculateAverageTip(olderSessions);
                
                if (olderAvgTip === 0) return;
                
                const change = ((recentAvgTip - olderAvgTip) / olderAvgTip) * 100;
                
                if (Math.abs(change) >= 15) {
                    const trend = change > 0 ? 'increased' : 'decreased';
                    const emoji = change > 0 ? '💸' : '📉';
                    this.sendNotification(
                        `Tip Trends ${emoji}`,
                        `Your average tip ${trend} ${Math.abs(change).toFixed(1)}% recently!`
                    );
                }
            }
            
            checkPeakTimes(sessions) {
                if (!settings.get('peakTime')) return;
                
                const timeSlots = {};
                let totalReadings = 0;
                
                sessions.forEach(s => {
                    if (!s.readings) return;
                    s.readings.forEach(r => {
                        totalReadings++;
                        const hour = this.parseTimeToHour(r.timestamp);
                        if (hour !== null) {
                            timeSlots[hour] = (timeSlots[hour] || 0) + 1;
                        }
                    });
                });
                
                if (totalReadings < 20) return;
                
                const timeSlotKeys = Object.keys(timeSlots);
                if (timeSlotKeys.length === 0) return;
                
                const peakHour = timeSlotKeys.reduce((peak, hour) => 
                    timeSlots[hour] > (timeSlots[peak] || 0) ? hour : peak
                );
                
                const peakCount = timeSlots[peakHour];
                const peakPercentage = (peakCount / totalReadings) * 100;
                
                if (peakPercentage >= 20) {
                    const timeRange = `${peakHour}:00-${parseInt(peakHour) + 1}:00`;
                    this.sendNotification(
                        'Peak Time Alert ⏰',
                        `${timeRange} is your busiest time - ${peakPercentage.toFixed(1)}% of readings!`
                    );
                }
            }
            
            calculateAverageTip(sessions) {
                let totalTips = 0;
                let totalReadings = 0;
                
                sessions.forEach(s => {
                    if (!s.readings) return;
                    s.readings.forEach(r => {
                        totalReadings++;
                        totalTips += r.tip || 0;
                    });
                });
                
                return totalReadings > 0 ? totalTips / totalReadings : 0;
            }
            
            parseTimeToHour(timestamp) {
                const match = timestamp.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i);
                if (!match) return null;
                
                let hour = parseInt(match[1]);
                const period = match[3].toUpperCase();
                
                if (period === 'PM' && hour !== 12) hour += 12;
                if (period === 'AM' && hour === 12) hour = 0;
                
                return hour;
            }
            
            sendNotification(title, body) {
                if ('serviceWorker' in navigator && Notification.permission === 'granted') {
                    navigator.serviceWorker.ready.then(registration => {
                        registration.showNotification(title, {
                            body: body,
                            icon: window.APP_LOGO,
                            badge: window.APP_LOGO,
                            tag: 'analytics-notification',
                            vibrate: [100, 50, 100]
                        });
                    });
                }
            }
        }
        
        const analyticsNotifier = new AnalyticsNotifier();
        
        // Timer expiration notification
        function sendTimerNotification() {
            if (!settings.get('timerNotifications')) return;
            
            if ('serviceWorker' in navigator && Notification.permission === 'granted') {
                navigator.serviceWorker.ready.then(registration => {
                    registration.showNotification('Timer Finished! ⏰', {
                        body: 'Your tarot reading timer has expired.',
                        icon: window.APP_LOGO,
                        badge: window.APP_LOGO,
                        tag: 'timer-expired',
                        requireInteraction: true,
                        vibrate: [200, 100, 200, 100, 200],
                        actions: [
                            {
                                action: 'reset-timer',
                                title: 'Reset Timer',
                                icon: window.APP_LOGO
                            }
                        ]
                    }).then(() => {
                        // Fallback for localhost - also try direct notification
                        if (isDevelopmentMode()) {
                            setTimeout(() => {
                                try {
                                    new Notification('Timer Finished! ⏰', {
                                        body: 'Your tarot reading timer has expired.',
                                        icon: window.APP_LOGO
                                    });
                                } catch (err) {}
                            }, 100);
                        }
                    }).catch(() => {});
                }).catch(() => {});
            }
        }
        
        // Background sync handler
        async function handleBackgroundSync() {
            try {
                if (session.sessionId && session.readings.length > 0) {
                    await session.save();
                }
            } catch (error) {}
        }
        
        // Background backup handler
        async function handleBackgroundBackup() {
            try {
                // Create backup in localStorage with timestamp
                const backup = {
                    timestamp: new Date().toISOString(),
                    sessionData: {
                        sessionId: session.sessionId,
                        location: session.location,
                        selectedDay: session.selectedDay,
                        price: session.price,
                        readings: session.readings
                    }
                };
                localStorage.setItem('readingTracker_backup', JSON.stringify(backup));
            } catch (error) {}
        }
        
        // Register for background sync when going offline
        function registerBackgroundSync() {
            if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {
                navigator.serviceWorker.ready.then(registration => {
                    return registration.sync.register('background-sync-readings');
                }).catch(() => {});
            }
        }
        
        // Send push notification (for testing)
        function sendTestNotification() {
            
            if (!('Notification' in window)) {
                alert('This browser does not support notifications');
                return;
            }
            
            if (Notification.permission === 'denied') {
                alert('Notifications are blocked. Please enable them in browser settings.');
                return;
            }
            
            if (Notification.permission === 'default') {
                Notification.requestPermission().then(permission => {
                    if (permission === 'granted') {
                        showTestNotification();
                    } else {
                        alert('Notification permission denied');
                    }
                });
            } else if (Notification.permission === 'granted') {
                showTestNotification();
            }
        }
        
        function showTestNotification() {
            // Try direct notification first
            try {
                new Notification('Test Notification', {
                    body: 'Direct browser notification test',
                    icon: '/logo192.png'
                });
            } catch (err) {}
            
            // Also try service worker notification
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.ready.then(registration => {
                    registration.showNotification(window.APP_TITLE, {
                        body: 'Test notification - this should appear on desktop!',
                        icon: '/logo192.png',
                        badge: '/logo192.png',
                        vibrate: [100, 50, 100],
                        tag: 'test-notification',
                        actions: [
                            { action: 'open', title: 'Open App' },
                            { action: 'close', title: 'Close' }
                        ]
                    }).catch(() => {});
                }).catch(() => {});
            }
        }
        
        function fallbackNotification() {
            new Notification(window.APP_TITLE, {
                body: 'Test notification - fallback method',
                icon: '/logo192.png'
            });
        }

        function startNewSession() {
            vibrate([100, 50, 100]);
            if (confirm('Start a new session? This will unload all current data and start over.')) {
                session.startOver();
                resetTimer();
                document.getElementById('timerInput').value = '15';
                showSnackbar('Ready to create new session', 'success');
            }
        }

        async function showLoadSession() {
            if (!session.user) {
                return;
            }
            
            vibrate([50]);
            const btn = document.querySelector('.btn-load-session');
            const originalText = btn.textContent;
            btn.innerHTML = '<span class="spinner inline"></span>Loading...';
            btn.classList.add('loading');
            
            try {
                const { data, error } = await supabase
                    .from('blacksheep_reading_tracker_sessions')
                    .select('*')
                    .eq('user_name', session.user)
                    .order('session_date', { ascending: false })
                    .order('created_at', { ascending: false });
                
                if (data && data.length > 0) {
                    const sessionsList = document.getElementById('sessionsList');
                    sessionsList.innerHTML = data.map(sessionData => {
                        const readingCount = sessionData.readings ? sessionData.readings.length : 0;
                        const date = new Date(sessionData.session_date).toLocaleDateString();
                        const dayOfWeek = new Date(sessionData.session_date).toLocaleDateString('en-US', { weekday: 'short' });
                        const baseTotal = sessionData.readings ? sessionData.readings.reduce((sum, r) => sum + (r.price || sessionData.reading_price || 0), 0) : 0;
                        const tipsTotal = sessionData.readings ? sessionData.readings.reduce((sum, reading) => sum + (reading.tip || 0), 0) : 0;
                        const grandTotal = baseTotal + tipsTotal;
                        return `
                            <div class="session-item" onclick="selectSession('${sessionData.id}')">
                                <div class="session-info">${sessionData.location || 'No location'} - ${dayOfWeek} ${date}</div>
                                <div class="session-details">${readingCount} readings • $${grandTotal.toFixed(2)}</div>
                            </div>
                        `;
                    }).join('');
                    showSheet('sessionOverlay', 'sessionSheet');
                } else {
                    showSnackbar('No existing sessions found', 'error');
                }
            } catch (error) {
                showSnackbar('Failed to load sessions', 'error');
            } finally {
                btn.textContent = originalText;
                btn.classList.remove('loading');
            }
        }

        function closeSessionSheet() {
            vibrate([30]);
            hideSheet('sessionOverlay', 'sessionSheet');
        }

        async function selectSession(sessionId) {
            vibrate([50]);
            const sessionItem = event.target.closest('.session-item');
            const originalHTML = sessionItem.innerHTML;
            sessionItem.innerHTML = '<div class="session-info"><span class="spinner"></span>Loading session...</div>';
            sessionItem.style.pointerEvents = 'none';
            
            try {
                const { data, error } = await supabase
                    .from('blacksheep_reading_tracker_sessions')
                    .select('*')
                    .eq('id', sessionId)
                    .single();
                
                if (data) {
                    await loadExistingSession(data);
                    closeSessionSheet();
                } else {
                    showSnackbar('Session not found', 'error');
                }
            } catch (error) {
                showSnackbar('Failed to load session', 'error');
            } finally {
                sessionItem.innerHTML = originalHTML;
                sessionItem.style.pointerEvents = 'auto';
            }
        }

        async function loadExistingSession(sessionData) {
            console.log('Loading session data:', sessionData);
            session._loading = true;
            session.sessionId = sessionData.id;
            session.user = sessionData.user_name || '';
            session.location = sessionData.location || '';
            session.sessionDate = sessionData.session_date || '';
            session.price = sessionData.reading_price || 40;
            session.readings = sessionData.readings || [];
            session._loading = false;
            collapseSettings();
            showSnackbar(`Loaded session: ${sessionData.location} on ${sessionData.session_date}`);
        }

        async function createSession() {
            if (!session.canCreateSession) {
                showSnackbar('User, location and date are required', 'error');
                return;
            }
            
            vibrate([50]);
            const btn = document.querySelector('.btn-create-session');
            const originalText = btn.textContent;
            btn.innerHTML = '<span class="spinner inline"></span>Creating...';
            btn.classList.add('loading');
            
            try {
                const today = new Date().toISOString().split('T')[0];
                const { data } = await supabase
                    .from('blacksheep_reading_tracker_sessions')
                    .select('*')
                    .eq('session_date', session.sessionDate)
                    .eq('user_name', session.user)
                    .eq('location', session.location)
                    .limit(1);
                
                if (data && data[0]) {
                    btn.textContent = originalText;
                    btn.classList.remove('loading');
                    const message = `${session.location} on ${session.sessionDate} already exists. Load existing session?`;
                    if (confirm(message)) {
                        session.sessionId = data[0].id;
                        session.readings = data[0].readings || [];
                        if (data[0].reading_price) session.price = data[0].reading_price;
                        collapseSettings();
                        showSnackbar(`Loaded existing session: ${session.location} on ${session.sessionDate}`);
                    } else {
                        session.location = '';
                        session.sessionDate = '';
                        showSnackbar('Location and date must be unique', 'error');
                    }
                    return;
                }
                
                const { data: newData } = await supabase
                    .from('blacksheep_reading_tracker_sessions')
                    .insert([{
                        session_date: session.sessionDate,
                        user_name: session.user,
                        location: session.location,
                        reading_price: session.price,
                        readings: session.readings
                    }])
                    .select();
                
                if (newData && newData[0]) {
                    session.sessionId = newData[0].id;
                    session.readings = []; // Clear readings for new session
                    collapseSettings();
                    showSnackbar('Session created successfully!');
                    
                    // Schedule reminder notification for session end (optional)
                    if ('serviceWorker' in navigator && Notification.permission === 'granted' && !isDevelopmentMode()) {
                        setTimeout(() => {
                            sendTestNotification();
                        }, 4 * 60 * 60 * 1000); // 4 hours later
                    }
                }
            } catch (error) {
                showSnackbar('Database error, using offline mode', 'error');
                registerBackgroundSync();
            } finally {
                btn.textContent = originalText;
                btn.classList.remove('loading');
            }
        }

        async function addReading() {
            if (!session.hasValidSession) {
                showSnackbar('Create session first', 'error');
                return;
            }
            
            vibrate([50]);
            const now = new Date();
            const timestamp = now.toISOString();
            session.addReading({ timestamp, tip: 0, price: session.price });
            
            // Trigger background backup after adding reading
            handleBackgroundBackup();
            
            // Skip analytics notifications during active session
        }

        function removeReading() {
            vibrate([50]);
            if (session.readings.length > 0) {
                const lastReading = session.readings[session.readings.length - 1];
                if (confirm(`Delete the ${lastReading.timestamp} reading?`)) {
                    vibrate([100, 50, 100]);
                    session.removeReading(session.readings.length - 1);
                }
            }
        }

        function updatePayment(index, method) {
            vibrate([30]);
            session.updateReading(index, 'payment', method);
        }

        let currentPaymentIndex = null;
        let currentSourceIndex = null;

        function showSheet(overlayId, sheetId) {
            document.getElementById(overlayId).style.display = 'block';
            document.getElementById(sheetId).style.display = 'block';
        }

        function hideSheet(overlayId, sheetId) {
            document.getElementById(overlayId).style.display = 'none';
            document.getElementById(sheetId).style.display = 'none';
        }

        function openPaymentSheet(index) {
            vibrate([30]);
            currentPaymentIndex = index;
            
            // Populate payment options from settings
            const paymentOptions = document.getElementById('paymentOptions');
            const methods = settings.get('paymentMethods');
            paymentOptions.innerHTML = methods.map(method => 
                `<button class="payment-option" onclick="selectPaymentMethod('${method}')">${method}</button>`
            ).join('') + '<button class="payment-option" onclick="selectCustomPayment()">Other</button>';
            
            showSheet('paymentOverlay', 'paymentSheet');
        }

        function closePaymentSheet() {
            vibrate([30]);
            hideSheet('paymentOverlay', 'paymentSheet');
            currentPaymentIndex = null;
        }

        function selectPaymentMethod(method) {
            vibrate([30]);
            if (currentPaymentIndex !== null) {
                session.updateReading(currentPaymentIndex, 'payment', method);
                closePaymentSheet();
            }
        }

        function selectCustomPayment() {
            vibrate([30]);
            const currentValue = currentPaymentIndex !== null && session.readings[currentPaymentIndex].payment ? session.readings[currentPaymentIndex].payment : '';
            const newValue = prompt('Enter payment method:', currentValue);
            if (newValue !== null && newValue.trim()) {
                session.updateReading(currentPaymentIndex, 'payment', newValue.trim());
                closePaymentSheet();
            }
        }

        function openSourceSheet(index) {
            vibrate([30]);
            currentSourceIndex = index;
            
            const sourceOptions = document.getElementById('sourceOptions');
            const sources = settings.get('sources');
            sourceOptions.innerHTML = sources.map(source => 
                `<button class="payment-option" onclick="selectSource('${source}')">${source}</button>`
            ).join('') + '<button class="payment-option" onclick="selectCustomSource()">Other</button>';
            
            showSheet('sourceOverlay', 'sourceSheet');
        }

        function closeSourceSheet() {
            vibrate([30]);
            hideSheet('sourceOverlay', 'sourceSheet');
            currentSourceIndex = null;
        }

        function selectSource(source) {
            vibrate([30]);
            if (currentSourceIndex !== null) {
                session.updateReading(currentSourceIndex, 'source', source);
                closeSourceSheet();
            }
        }

        function selectCustomSource() {
            vibrate([30]);
            const currentValue = currentSourceIndex !== null && session.readings[currentSourceIndex].source ? session.readings[currentSourceIndex].source : '';
            const newValue = prompt('Enter source:', currentValue);
            if (newValue !== null && newValue.trim()) {
                session.updateReading(currentSourceIndex, 'source', newValue.trim());
                closeSourceSheet();
            }
        }



        function deleteReading(index) {
            vibrate([50]);
            const reading = session.readings[index];
            const displayTime = session.formatTimestamp(reading.timestamp);
            if (confirm(`Delete the ${displayTime} reading?`)) {
                vibrate([100, 50, 100]);
                session.removeReading(index);
            }
        }




        function collapseSettings() {
            const content = document.getElementById('settingsContent');
            const icon = document.querySelector('.collapse-icon');
            content.classList.remove('open');
            icon.classList.remove('open');
        }

        function toggleSettings() {
            vibrate([50]);
            const content = document.getElementById('settingsContent');
            const icon = document.querySelector('.collapse-icon');
            content.classList.toggle('open');
            icon.classList.toggle('open');
        }

        let timerInterval = null;
        let timerSeconds = 900; // 15 minutes default
        let isRunning = false;
        let isBlinking = false;
        let alarmInterval = null;
        let audioContext = null;
        let wakeLock = null;
        let silentAudio = null;

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playBeep(frequency = 1000, duration = 0.15) {
            if (!settings.get('sound')) return;
            
            initAudio();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = 'square';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playAlarmSequence() {
            if (!settings.get('sound')) return;
            
            // Three rapid beeps
            playBeep(1000, 0.1);
            setTimeout(() => playBeep(1000, 0.1), 150);
            setTimeout(() => playBeep(1000, 0.1), 300);
            // Longer tone after gap
            setTimeout(() => playBeep(1000, 0.4), 600);
        }

        function vibrate(pattern) {
            if (navigator.vibrate && settings.get('haptic')) {
                navigator.vibrate(pattern);
            }
        }

        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <span>${message}</span>
                <button class="toast-close" onclick="this.parentElement.remove()">×</button>
            `;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                if (toast.parentElement) {
                    toast.remove();
                }
            }, 3000);
        }

        function showSnackbar(message, type = 'info') {
            const snackbar = document.createElement('div');
            snackbar.className = `snackbar ${type}`;
            snackbar.textContent = message;
            document.body.appendChild(snackbar);
            
            setTimeout(() => {
                if (snackbar.parentElement) {
                    snackbar.remove();
                }
            }, 2000);
        }
        
        function showUpdateNotification() {
            const updateBar = document.createElement('div');
            updateBar.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                background: #007bff;
                color: white;
                padding: 12px;
                text-align: center;
                z-index: 10000;
                font-size: 14px;
            `;
            updateBar.innerHTML = `
                New version available! 
                <button onclick="updateApp()" style="background: white; color: #007bff; border: none; padding: 4px 8px; margin-left: 8px; border-radius: 4px; cursor: pointer;">Update Now</button>
                <button onclick="this.parentElement.remove()" style="background: transparent; color: white; border: 1px solid white; padding: 4px 8px; margin-left: 4px; border-radius: 4px; cursor: pointer;">Later</button>
            `;
            document.body.appendChild(updateBar);
        }
        
        function updateApp() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistration().then(registration => {
                    if (registration && registration.waiting) {
                        registration.waiting.postMessage({ type: 'SKIP_WAITING' });
                        window.location.reload();
                    } else {
                        // Force reload if no waiting worker
                        window.location.reload(true);
                    }
                }).catch(() => {
                    // Fallback to hard reload
                    window.location.reload(true);
                });
            } else {
                window.location.reload(true);
            }
        }

        function checkForUpdates() {
            if (settings.get('haptic')) vibrate([50]);
            
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistration().then(registration => {
                    if (registration) {
                        showSnackbar('Checking for updates...', 'info');
                        registration.update().then(() => {
                            setTimeout(() => {
                                showSnackbar('No updates available', 'success');
                            }, 1000);
                        }).catch(() => {
                            showSnackbar('Update check failed', 'error');
                        });
                    } else {
                        showSnackbar('Service worker not available', 'error');
                    }
                }).catch(() => {
                    showSnackbar('Update check failed', 'error');
                });
            } else {
                showSnackbar('Updates not supported', 'error');
            }
        }

        function startAlarm() {
            playAlarmSequence();
            alarmInterval = setInterval(() => {
                playAlarmSequence();
            }, 1500);
        }

        function stopAlarm() {
            if (alarmInterval) {
                clearInterval(alarmInterval);
                alarmInterval = null;
            }
        }

        function adjustTime(minutes) {
            timer.adjustTime(minutes);
        }

        function initCanvas() {
            canvas = document.getElementById('timerCanvas');
            ctx = canvas.getContext('2d');
            // Ensure crisp lines
            ctx.imageSmoothingEnabled = false;
            drawTimer();
        }

        function drawTimer() {
            if (!ctx) return;
            
            const centerX = 150;
            const centerY = 150;
            const radius = 120;
            
            // Clear canvas
            ctx.clearRect(0, 0, 300, 300);
            
            // Background circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 12;
            ctx.stroke();
            
            // Progress arc
            if (isRunning) {
                // When running: show actual progress with gradient colors
                const progress = timerSeconds / totalSeconds;
                if (progress > 0) {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, -Math.PI/2, -Math.PI/2 + (2 * Math.PI * progress));
                    
                    // Calculate gradient color (green to red)
                    const red = Math.round(220 * (1 - progress) + 40 * progress);
                    const green = Math.round(167 * progress + 53 * (1 - progress));
                    const blue = Math.round(69 * (1 - progress));
                    ctx.strokeStyle = `rgb(${red}, ${green}, ${blue})`;
                    
                    ctx.lineWidth = 12;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                }
            } else {
                // When not running: always show full green circle
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.strokeStyle = '#28a745'; // Always green
                ctx.lineWidth = 12;
                ctx.stroke();
            }
            
            // Time text
            const minutes = Math.floor(timerSeconds / 60);
            const seconds = timerSeconds % 60;
            const timeText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Text color
            if (isRunning) {
                const progress = timerSeconds / totalSeconds;
                const red = Math.round(51 * (1 - progress) + 220 * (1 - progress));
                const green = Math.round(51 * progress + 53 * (1 - progress));
                const blue = Math.round(51 * (1 - progress));
                ctx.fillStyle = `rgb(${red}, ${green}, ${blue})`;
            } else {
                ctx.fillStyle = '#333'; // Dark gray when not running
            }
            ctx.font = 'bold 72px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(timeText, centerX, centerY);
            
            // Animate if running
            if (isRunning) {
                canvasAnimationId = requestAnimationFrame(drawTimer);
            }
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(timerSeconds / 60);
            const seconds = timerSeconds % 60;
            document.getElementById('timerDisplay').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Update canvas
            if (canvas) {
                drawTimer();
            }
        }

        let keepAwakeInterval = null;
        let canvasAnimationId = null;
        let canvas = null;
        let ctx = null;
        let totalSeconds = 900;

        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                }
            } catch (err) {
            }
            
            // Always use audio fallback as additional insurance
            try {
                initAudio();
                // Create looping silent audio
                const buffer = audioContext.createBuffer(1, 1, 22050);
                silentAudio = audioContext.createBufferSource();
                silentAudio.buffer = buffer;
                silentAudio.loop = true;
                const gainNode = audioContext.createGain();
                silentAudio.connect(gainNode);
                gainNode.connect(audioContext.destination);
                gainNode.gain.setValueAtTime(0.001, audioContext.currentTime); // Very quiet but not silent
                silentAudio.start();
            } catch (audioErr) {
            }
        }

        function releaseWakeLock() {
            if (wakeLock) {
                wakeLock.release();
                wakeLock = null;
            }
            if (silentAudio) {
                silentAudio.stop();
                silentAudio = null;
            }
            if (keepAwakeInterval) {
                clearInterval(keepAwakeInterval);
                keepAwakeInterval = null;
                document.body.style.transform = '';
            }
        }

        function startTimer() {
            timer.start();
        }

        function pauseTimer() {
            timer.pause();
        }

        function resetTimer(showToastMessage = false) {
            timer.reset(showToastMessage);
        }

        function startBlinking() {
            isBlinking = true;
            document.getElementById('timerDisplay').classList.add('blink');
        }

        function stopBlinking() {
            isBlinking = false;
            document.getElementById('timerDisplay').classList.remove('blink');
        }

        function startWarningBlink() {
            document.getElementById('timerDisplay').classList.add('warning');
        }

        function stopWarningBlink() {
            document.getElementById('timerDisplay').classList.remove('warning');
        }

        // Initialize audio context on first user interaction
        document.addEventListener('click', initAudio, { once: true });

        document.getElementById('timerInput').addEventListener('input', function() {
            if (!timer.isRunning) {
                timer.seconds = parseInt(this.value) * 60;
            }
        });

        // Initialize canvas on page load
        window.addEventListener('load', function() {
            timer.initCanvas();
            
            // Set default timer from settings
            const defaultMinutes = settings.get('defaultTimer');
            document.getElementById('timerInput').value = defaultMinutes;
            timer.seconds = defaultMinutes * 60;
        });

        document.getElementById('price').addEventListener('input', function() {
            session.price = parseFloat(this.value) || 0;
        });

        async function showUserSelection() {
            vibrate([30]);
            showSheet('userOverlay', 'userSheet');
            
            const userList = document.getElementById('userList');
            userList.innerHTML = '<div style="text-align: center; padding: 20px;"><div class="spinner"></div></div>';
            
            await session.loadUsers();
        }
        
        function hideUserSelection() {
            vibrate([30]);
            hideSheet('userOverlay', 'userSheet');
        }
        
        function selectUser(userName) {
            vibrate([50]);
            
            // Check if switching users during active session
            if (session.hasValidSession && session.user && session.user !== userName) {
                const message = `Switching users will unload the current session (${session.location} on ${session.sessionDate}). Continue?`;
                if (!confirm(message)) {
                    return;
                }
            }
            
            // Overwrite localStorage with clean user object
            localStorage.setItem(`readingTracker_${userName}`, JSON.stringify({
                user: userName,
                sessionId: null,
                location: '',
                selectedDay: null,
                price: 40,
                readings: []
            }));
            
            session.user = userName;
            session.loadFromStorage();
            hideUserSelection();
        }
        
        document.getElementById('location').addEventListener('input', function() {
            session.location = this.value;
        });
        
        document.getElementById('sessionDate').addEventListener('input', function() {
            session.sessionDate = this.value;
        });
        
        function addNewUser() {
            vibrate([50]);
            const userName = prompt('Enter new user name:');
            if (userName && userName.trim()) {
                const trimmedName = userName.trim();
                session.user = trimmedName;
                hideUserSelection();
            }
        }

        function handleCreateSession() {
            const createBtn = document.querySelector('.btn-create-session');
            if (createBtn.classList.contains('inactive')) {
                showSnackbar('User, location and date are required', 'error');
                vibrate([50]);
            } else {
                createSession();
            }
        }

        // Settings Drawer Functions
        function openSettingsDrawer() {
            vibrate([50]);
            document.getElementById('settingsOverlay').classList.add('open');
            document.getElementById('settingsDrawer').classList.add('open');
            settings.updateToggleUI();
        }

        function closeSettingsDrawer() {
            vibrate([30]);
            document.getElementById('settingsOverlay').classList.remove('open');
            document.getElementById('settingsDrawer').classList.remove('open');
            // Also close any open payment methods sheet
            closePaymentMethodsSheet();
        }

        function toggleSetting(key) {
            if (settings.get('haptic')) vibrate([30]);
            settings.toggle(key);
            
            // Special handling for certain settings
            if (key === 'defaultTimer') {
                const minutes = settings.get('defaultTimer');
                document.getElementById('timerInput').value = minutes;
                timer.seconds = minutes * 60;
            }
        }

        function updateSetting(key, value) {
            if (settings.get('haptic')) vibrate([30]);
            if (key === 'defaultTimer') {
                settings.set(key, parseInt(value));
                document.getElementById('timerInput').value = value;
                timer.seconds = parseInt(value) * 60;
            } else {
                settings.set(key, value);
            }
        }

        function customizePaymentMethods() {
            if (settings.get('haptic')) vibrate([50]);
            showPaymentMethodsSheet();
        }
        
        function showPaymentMethodsSheet() {
            const methods = settings.get('paymentMethods');
            const list = document.getElementById('paymentMethodsList');
            if (!list) return;
            
            list.innerHTML = methods.map((method, index) => `
                <div class="payment-method-item">
                    <input type="text" class="payment-method-input" value="${method}" 
                           onchange="updatePaymentMethod(${index}, this.value)">
                    <button class="payment-method-delete" onclick="deletePaymentMethod(${index})">Delete</button>
                </div>
            `).join('');
            showSheet('paymentMethodsOverlay', 'paymentMethodsSheet');
        }
        
        function closePaymentMethodsSheet() {
            if (settings.get('haptic')) vibrate([30]);
            hideSheet('paymentMethodsOverlay', 'paymentMethodsSheet');
        }
        
        function updatePaymentMethod(index, value) {
            if (settings.get('haptic')) vibrate([30]);
            const methods = [...settings.get('paymentMethods')];
            methods[index] = value.trim();
            settings.set('paymentMethods', methods.filter(m => m));
            showSnackbar('Setting saved', 'success');
        }
        
        function deletePaymentMethod(index) {
            if (settings.get('haptic')) vibrate([50]);
            const methods = [...settings.get('paymentMethods')];
            methods.splice(index, 1);
            settings.set('paymentMethods', methods);
            showPaymentMethodsSheet(); // Refresh the list
        }
        
        function addPaymentMethod() {
            if (settings.get('haptic')) vibrate([50]);
            const methods = [...settings.get('paymentMethods')];
            methods.push('New Method');
            settings.set('paymentMethods', methods);
            showPaymentMethodsSheet(); // Refresh the list
        }

        function customizeSources() {
            if (settings.get('haptic')) vibrate([50]);
            showSourcesSheet();
        }
        
        function showSourcesSheet() {
            const sources = settings.get('sources');
            const list = document.getElementById('sourcesList');
            if (!list) return;
            
            list.innerHTML = sources.map((source, index) => `
                <div class="payment-method-item">
                    <input type="text" class="payment-method-input" value="${source}" 
                           onchange="updateSource(${index}, this.value)">
                    <button class="payment-method-delete" onclick="deleteSource(${index})">Delete</button>
                </div>
            `).join('');
            showSheet('sourcesOverlay', 'sourcesSheet');
        }
        
        function closeSourcesSheet() {
            if (settings.get('haptic')) vibrate([30]);
            hideSheet('sourcesOverlay', 'sourcesSheet');
        }
        
        function updateSource(index, value) {
            if (settings.get('haptic')) vibrate([30]);
            const sources = [...settings.get('sources')];
            sources[index] = value.trim();
            settings.set('sources', sources.filter(s => s));
            showSnackbar('Setting saved', 'success');
        }
        
        function deleteSource(index) {
            if (settings.get('haptic')) vibrate([50]);
            const sources = [...settings.get('sources')];
            sources.splice(index, 1);
            settings.set('sources', sources);
            showSourcesSheet(); // Refresh the list
        }
        
        function addSource() {
            if (settings.get('haptic')) vibrate([50]);
            const sources = [...settings.get('sources')];
            sources.push('New Source');
            settings.set('sources', sources);
            showSourcesSheet(); // Refresh the list
        }

        // Report Maker Functions
        let reportData = [];
        
        function showReportMaker() {
            if (!session.user) {
                showSnackbar('Select a user first', 'error');
                return;
            }
            
            if (settings.get('haptic')) vibrate([50]);
            
            // Set default date range to last 30 days
            const today = new Date();
            const thirtyDaysAgo = new Date(today);
            thirtyDaysAgo.setDate(today.getDate() - 30);
            
            document.getElementById('startDate').value = thirtyDaysAgo.toISOString().split('T')[0];
            document.getElementById('endDate').value = today.toISOString().split('T')[0];
            
            document.getElementById('reportModal').style.display = 'block';
        }
        
        function closeReportMaker() {
            if (settings.get('haptic')) vibrate([30]);
            document.getElementById('reportModal').style.display = 'none';
        }
        
        function closeReportResults() {
            if (settings.get('haptic')) vibrate([30]);
            document.getElementById('reportResultsModal').style.display = 'none';
        }
        
        function setDateRange(preset) {
            if (settings.get('haptic')) vibrate([30]);
            
            // Update active button
            document.querySelectorAll('.report-preset-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            const customInputs = document.getElementById('customDateInputs');
            
            // Always hide/show custom inputs based on selection
            if (preset === 'custom') {
                customInputs.style.display = 'block';
                return; // Don't set dates for custom
            } else {
                customInputs.style.display = 'none';
            }
            
            const today = new Date();
            let startDate, endDate;
            
            switch (preset) {
                case 'today':
                    startDate = new Date(today);
                    endDate = new Date(today);
                    endDate.setHours(23, 59, 59, 999);
                    break;
                case 'weekend':
                    // Find most recent weekend (Friday to Sunday)
                    const dayOfWeek = today.getDay();
                    console.log('Today:', today, 'Day of week:', dayOfWeek);
                    let friday = new Date(today);
                    if (dayOfWeek === 0) { // Sunday - current weekend
                        friday.setDate(today.getDate() - 2); // Go back to Friday
                    } else if (dayOfWeek === 6) { // Saturday - current weekend
                        friday.setDate(today.getDate() - 1); // Go back to Friday
                    } else if (dayOfWeek === 5) { // Friday - current weekend
                        // Friday stays as is
                    } else { // Mon-Thu, get previous weekend
                        const daysToSubtract = dayOfWeek + 2; // Mon=3, Tue=4, Wed=5, Thu=6
                        friday.setDate(today.getDate() - daysToSubtract);
                    }
                    friday.setHours(0, 0, 0, 0); // Set to start of Friday
                    console.log('Friday:', friday);
                    const sunday = new Date(friday);
                    sunday.setDate(friday.getDate() + 2); // Friday + 2 = Sunday
                    sunday.setHours(23, 59, 59, 999);
                    console.log('Sunday:', sunday);
                    // Subtract 1 day to account for timezone shift when converting to YYYY-MM-DD
                    const endDateAdjusted = new Date(sunday);
                    endDateAdjusted.setDate(sunday.getDate() - 1);
                    startDate = friday;
                    endDate = endDateAdjusted;
                    break;
                case 'month':
                    startDate = new Date(today.getFullYear(), today.getMonth(), 1);
                    endDate = new Date(today);
                    endDate.setHours(23, 59, 59, 999);
                    break;
                case 'ytd':
                    startDate = new Date(today.getFullYear(), 0, 1);
                    endDate = new Date(today);
                    endDate.setHours(23, 59, 59, 999);
                    break;
                case 'year':
                    startDate = new Date(today);
                    startDate.setFullYear(today.getFullYear() - 1);
                    endDate = new Date(today);
                    endDate.setHours(23, 59, 59, 999);
                    break;
                case 'lastYear':
                    startDate = new Date(today.getFullYear() - 1, 0, 1);
                    endDate = new Date(today.getFullYear() - 1, 11, 31);
                    endDate.setHours(23, 59, 59, 999);
                    break;
                case 'all':
                    startDate = new Date('2020-01-01');
                    endDate = new Date(today);
                    endDate.setHours(23, 59, 59, 999);
                    break;
                case 'custom':
                default:
                    return;
            }
            
            document.getElementById('startDate').value = startDate.toISOString().split('T')[0];
            document.getElementById('endDate').value = endDate.toISOString().split('T')[0];
            console.log('setDateRange endDate:', endDate.toISOString().split('T')[0]);
        }
        
        async function generateReport() {
            if (settings.get('haptic')) vibrate([50]);
            
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            console.log('generateReport endDate:', endDate);
            const groupBy = document.getElementById('groupBy').value;
            const activePreset = document.querySelector('.report-preset-btn.active')?.textContent?.toLowerCase() || 'custom';
            
            if (!startDate || !endDate) {
                showSnackbar('Please select start and end dates', 'error');
                return;
            }
            
            try {
                // Get all sessions, then filter by session_date
                const { data } = await supabase
                    .from('blacksheep_reading_tracker_sessions')
                    .select('*')
                    .eq('user_name', session.user)
                    .order('session_date', { ascending: false });
                
                if (!data || data.length === 0) {
                    showSnackbar('No data found', 'error');
                    return;
                }
                
                // Filter by session_date (sessions with no readings are excluded)
                const startDateTime = new Date(normalizeDate(startDate));
                const endDateTime = new Date(normalizeDate(endDate));
                endDateTime.setHours(23, 59, 59, 999);
                
                const filteredData = data.filter(sessionData => {
                    const readings = sessionData.readings || [];
                    if (readings.length === 0) return false; // Exclude empty sessions
                    
                    const sessionDateTime = new Date(normalizeDate(sessionData.session_date));
                    return sessionDateTime >= startDateTime && sessionDateTime <= endDateTime;
                });
                
                if (filteredData.length === 0) {
                    showSnackbar('No data found for selected date range', 'error');
                    return;
                }
                
                reportData = filteredData;

                const reportHtml = generateReportHtml(filteredData, groupBy, startDate, endDate);
                document.getElementById('reportContent').innerHTML = reportHtml;
                
                // Enable export button
                document.getElementById('exportBtn').disabled = false;
                
                closeReportMaker();
                document.getElementById('reportResultsModal').style.display = 'block';
                
            } catch (error) {
                showSnackbar('Failed to generate report', 'error');
            }
        }
        
        function generateReportHtml(data, groupBy, startDate, endDate) {
            const groups = {};
            let totalReadings = 0;
            let totalBase = 0;
            let totalTips = 0;
            
            // Group data
            data.forEach(sessionData => {
                const readings = sessionData.readings || [];
                
                if (groupBy === 'payment' || groupBy === 'source') {
                    // Group by individual readings
                    readings.forEach(reading => {
                        const baseTotal = reading.price || sessionData.reading_price || 0;
                        const tipsTotal = reading.tip || 0;
                        
                        let groupKey;
                        if (groupBy === 'payment') {
                            groupKey = reading.payment || 'No Payment Method';
                        } else {
                            groupKey = reading.source || 'No Source';
                        }
                        
                        if (!groups[groupKey]) {
                            groups[groupKey] = {
                                totalReadings: 0,
                                totalBase: 0,
                                totalTips: 0
                            };
                        }
                        
                        groups[groupKey].totalReadings += 1;
                        groups[groupKey].totalBase += baseTotal;
                        groups[groupKey].totalTips += tipsTotal;
                        
                        totalReadings += 1;
                        totalBase += baseTotal;
                        totalTips += tipsTotal;
                    });
                } else {
                    // Group by sessions
                    const readingCount = readings.length;
                    const baseTotal = readings.reduce((sum, r) => sum + (r.price || sessionData.reading_price || 0), 0);
                    const tipsTotal = readings.reduce((sum, r) => sum + (r.tip || 0), 0);
                    
                    let groupKey;
                    if (groupBy === 'location') {
                        groupKey = sessionData.location;
                    } else {
                        // Use session date as event date
                        groupKey = new Date(normalizeDate(sessionData.session_date)).toLocaleDateString();
                    }
                    
                    if (!groups[groupKey]) {
                        groups[groupKey] = {
                            sessions: [],
                            totalReadings: 0,
                            totalBase: 0,
                            totalTips: 0
                        };
                    }
                    
                    groups[groupKey].sessions.push(sessionData);
                    groups[groupKey].totalReadings += readingCount;
                    groups[groupKey].totalBase += baseTotal;
                    groups[groupKey].totalTips += tipsTotal;
                    
                    totalReadings += readingCount;
                    totalBase += baseTotal;
                    totalTips += tipsTotal;
                }
            });
            
            // Generate HTML
            let html = `<div style="margin-bottom: 20px;">`;
            const [startYear, startMonth, startDay] = startDate.split('-');
            const [endYear, endMonth, endDay] = endDate.split('-');
            const formattedStartDate = `${parseInt(startMonth)}/${parseInt(startDay)}/${startYear}`;
            const formattedEndDate = `${parseInt(endMonth)}/${parseInt(endDay)}/${endYear}`;
            html += `<h3>Report: ${formattedStartDate} to ${formattedEndDate}</h3>`;
            const groupLabels = { location: 'Location', date: 'Date', payment: 'Payment Method', source: 'Referral Source' };
            html += `<p>Grouped by: ${groupLabels[groupBy]}</p>`;
            html += `</div>`;
            
            // Sort group keys by date for date grouping
            const sortedGroupKeys = groupBy === 'date' 
                ? Object.keys(groups).sort((a, b) => new Date(a) - new Date(b))
                : Object.keys(groups);
            
            sortedGroupKeys.forEach(groupKey => {
                const group = groups[groupKey];
                html += `<div class="report-group">`;
                html += `<div class="report-group-header">${groupKey}</div>`;
                
                if (groupBy === 'payment' || groupBy === 'source') {
                    // Show summary for payment/source grouping
                    html += `<div class="report-session">`;
                    html += `<div class="report-stats">`;
                    html += `<div class="report-stat"><span>Readings:</span><span>${group.totalReadings}</span></div>`;
                    html += `<div class="report-stat"><span>Base:</span><span>$${group.totalBase.toFixed(2)}</span></div>`;
                    html += `<div class="report-stat"><span>Tips:</span><span>$${group.totalTips.toFixed(2)}</span></div>`;
                    html += `<div class="report-stat"><span><strong>Total:</strong></span><span><strong>$${(group.totalBase + group.totalTips).toFixed(2)}</strong></span></div>`;
                    html += `</div></div>`;
                } else {
                    // Show individual sessions for location/date grouping (sorted by date)
                    const sortedSessions = group.sessions.sort((a, b) => {
                        const dateA = new Date(normalizeDate(a.session_date));
                        const dateB = new Date(normalizeDate(b.session_date));
                        return dateA - dateB;
                    });
                    
                    sortedSessions.forEach(sessionData => {
                        const readings = sessionData.readings || [];
                        const readingCount = readings.length;
                        const baseTotal = readings.reduce((sum, r) => sum + (r.price || sessionData.reading_price || 0), 0);
                        const tipsTotal = readings.reduce((sum, r) => sum + (r.tip || 0), 0);
                        const sessionTotal = baseTotal + tipsTotal;
                        
                        const eventDate = new Date(normalizeDate(sessionData.session_date)).toLocaleDateString();
                        
                        html += `<div class="report-session">`;
                        html += `<div class="report-session-header">${eventDate}</div>`;
                        html += `<div class="report-stats">`;
                        html += `<div class="report-stat"><span>Readings:</span><span>${readingCount}</span></div>`;
                        html += `<div class="report-stat"><span>Base:</span><span>$${baseTotal.toFixed(2)}</span></div>`;
                        html += `<div class="report-stat"><span>Tips:</span><span>$${tipsTotal.toFixed(2)}</span></div>`;
                        html += `<div class="report-stat"><span><strong>Total:</strong></span><span><strong>$${sessionTotal.toFixed(2)}</strong></span></div>`;
                        html += `</div></div>`;
                    });
                    
                    // Group totals for location/date grouping
                    if (group.sessions && group.sessions.length > 1) {
                        html += `<div style="margin-top: 12px; padding: 12px; background: #e8f5e8; border-radius: 4px; text-align: center;">`;
                        html += `<div style="font-weight: bold; margin-bottom: 4px;">${groupKey} Total</div>`;
                        html += `<div style="font-weight: bold; font-size: 18px;">$${(group.totalBase + group.totalTips).toFixed(2)}</div>`;
                        html += `</div>`;
                    }
                }
                html += `</div>`;
            });
            
            html += `<div class="report-totals">`;
            html += `<h3>Grand Totals</h3>`;
            html += `<div class="report-totals-grid">`;
            if (groupBy === 'payment' || groupBy === 'source') {
                html += `<div class="report-total-item"><strong>${Object.keys(groups).length}</strong><br>${groupBy === 'payment' ? 'Payment Methods' : 'Sources'}</div>`;
            } else {
                html += `<div class="report-total-item"><strong>${data.length}</strong><br>Sessions</div>`;
            }
            html += `<div class="report-total-item"><strong>${totalReadings}</strong><br>Readings</div>`;
            html += `<div class="report-total-item"><strong>$${totalBase.toFixed(2)}</strong><br>Base Total</div>`;
            html += `<div class="report-total-item"><strong>$${totalTips.toFixed(2)}</strong><br>Tips Total</div>`;
            html += `</div>`;
            html += `<div class="grand-total">`;
            html += `<div>Grand Total</div>`;
            html += `<div>$${(totalBase + totalTips).toFixed(2)}</div>`;
            html += `</div></div>`;
            
            return html;
        }
        
        function exportReportData() {
            if (settings.get('haptic')) vibrate([50]);
            
            if (!reportData || reportData.length === 0) {
                showSnackbar('No report data to export', 'error');
                return;
            }
            
            // Create detailed CSV with individual readings
            const csvData = [];
            csvData.push(['Date', 'Location', 'Day', 'Reading Time', 'Reading Price', 'Tip', 'Payment Method', 'Source', 'Total']);
            
            reportData.forEach(sessionData => {
                const readings = sessionData.readings || [];
                if (readings.length === 0) {
                    // Session with no readings
                    csvData.push([
                        sessionData.session_date,
                        sessionData.location,
                        sessionData.session_date,
                        '',
                        sessionData.reading_price || 0,
                        0,
                        '',
                        '',
                        0
                    ]);
                } else {
                    readings.forEach(reading => {
                        const readingTotal = (reading.price || sessionData.reading_price || 0) + (reading.tip || 0);
                        const readingDate = new Date(reading.timestamp).toLocaleDateString();
                        const readingTime = new Date(reading.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                        
                        csvData.push([
                            readingDate,
                            sessionData.location,
                            sessionData.session_date,
                            readingTime,
                            sessionData.reading_price || 0,
                            reading.tip || 0,
                            reading.payment || '',
                            reading.source || '',
                            readingTotal.toFixed(2)
                        ]);
                    });
                }
            });
            
            const csvContent = csvData.map(row => row.join(',')).join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            const startDate = document.getElementById('startDate').value || 'report';
            const endDate = document.getElementById('endDate').value || 'data';
            a.download = `tarot-report-${startDate}-to-${endDate}.csv`;
            a.click();
            
            URL.revokeObjectURL(url);
            showSnackbar('Report exported successfully', 'success');
        }

        async function exportData() {
            if (!session.user) {
                showSnackbar('Select a user first', 'error');
                return;
            }
            
            if (settings.get('haptic')) vibrate([50]);
            
            try {
                const { data } = await supabase
                    .from('blacksheep_reading_tracker_sessions')
                    .select('*')
                    .eq('user_name', session.user)
                    .order('session_date', { ascending: false });
                
                if (!data || data.length === 0) {
                    showSnackbar('No data to export', 'error');
                    return;
                }
                
                // Convert to CSV
                const csvData = [];
                csvData.push(['Date', 'User', 'Location', 'Day', 'Reading Price', 'Readings Count', 'Base Total', 'Tips Total', 'Grand Total']);
                
                data.forEach(sessionData => {
                    const readingCount = sessionData.readings ? sessionData.readings.length : 0;
                    const baseTotal = readingCount * (sessionData.reading_price || 0);
                    const tipsTotal = sessionData.readings ? sessionData.readings.reduce((sum, r) => sum + (r.tip || 0), 0) : 0;
                    const grandTotal = baseTotal + tipsTotal;
                    
                    csvData.push([
                        sessionData.session_date,
                        sessionData.user_name,
                        sessionData.location,
                        sessionData.session_date,
                        sessionData.reading_price,
                        readingCount,
                        baseTotal.toFixed(2),
                        tipsTotal.toFixed(2),
                        grandTotal.toFixed(2)
                    ]);
                });
                
                const csvContent = csvData.map(row => row.join(',')).join('\n');
                const blob = new Blob([csvContent], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `tarot-sessions-${new Date().toISOString().split('T')[0]}.csv`;
                a.click();
                
                URL.revokeObjectURL(url);
                showSnackbar('Data exported successfully', 'success');
            } catch (error) {
                showSnackbar('Export failed', 'error');
            }
        }



        // Check for saved session on page load
        window.addEventListener('load', async function() {
            const saved = localStorage.getItem('readingTracker');
            if (saved) {
                const state = JSON.parse(saved);
                const location = state.location || 'Unknown location';
                const date = state.sessionDate || state.selectedDay || 'Unknown date';
                const message = `I have saved data from ${location} on ${date}. Would you like to load that data? (OK) or start a new session? (Cancel)`;
                if (confirm(message)) {
                    session.loadFromStorage();
                } else {
                    session.startOver();
                }
            } else {
                // Initialize UI on first load
                session.updateUI();
            }
        });

        // Close sheets when clicking outside
        window.addEventListener('click', function(event) {
            if (event.target === document.getElementById('sessionOverlay')) {
                closeSessionSheet();
            }
        });
        
        // Network status monitoring
        window.addEventListener('online', () => {
            handleBackgroundSync();
        });
        
        window.addEventListener('offline', () => {
            registerBackgroundSync();
        });
        
        // Page visibility change - backup data when app goes to background (throttled)
        let lastBackupTime = 0;
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                const now = Date.now();
                // Only backup once per minute to prevent spam
                if (now - lastBackupTime > 60000) {
                    handleBackgroundBackup();
                    lastBackupTime = now;
                }
            }
        });
        
        // Development mode detection
        function isDevelopmentMode() {
            return window.location.hostname === 'localhost' || 
                   window.location.hostname === '127.0.0.1' ||
                   window.location.hostname.startsWith('192.168.') ||
                   window.location.hostname.startsWith('10.') ||
                   window.location.port === '8080' ||
                   window.location.protocol === 'file:' ||
                   window.location.search.includes('dev=true');
        }
        

    </script>
</body>
</html>